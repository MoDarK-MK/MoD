from typing import Dict, List, Optional, Tuple, Set, Pattern
from dataclasses import dataclass, field
from enum import Enum
import re
import json
from pathlib import Path
from collections import defaultdict
import hashlib
from abc import ABC, abstractmethod


class VulnerabilityType(Enum):
    XSS = "Cross-Site Scripting"
    SQL_INJECTION = "SQL Injection"
    RCE = "Remote Code Execution"
    COMMAND_INJECTION = "Command Injection"
    SSRF = "Server-Side Request Forgery"
    CSRF = "Cross-Site Request Forgery"
    XXE = "XML External Entity"
    SSTI = "Server-Side Template Injection"
    LDAP_INJECTION = "LDAP Injection"
    PATH_TRAVERSAL = "Path Traversal"
    INFORMATION_DISCLOSURE = "Information Disclosure"
    AUTHENTICATION_BYPASS = "Authentication Bypass"


class SeverityLevel(Enum):
    CRITICAL = 5
    HIGH = 4
    MEDIUM = 3
    LOW = 2
    INFO = 1


class ConfidenceLevel(Enum):
    CERTAIN = 1.0
    HIGH = 0.85
    MEDIUM = 0.65
    LOW = 0.4


@dataclass
class DetectionPattern:
    pattern: str
    compiled: Optional[Pattern] = None
    severity: SeverityLevel = SeverityLevel.MEDIUM
    confidence: ConfidenceLevel = ConfidenceLevel.MEDIUM
    false_positive_indicators: List[str] = field(default_factory=list)
    context_required: bool = False
    case_sensitive: bool = False
    
    def __post_init__(self):
        flags = 0 if self.case_sensitive else re.IGNORECASE
        try:
            self.compiled = re.compile(self.pattern, flags)
        except:
            self.compiled = None


@dataclass
class DetectionResult:
    is_vulnerable: bool
    severity: SeverityLevel
    confidence: float
    evidence: str
    indicators: List[str] = field(default_factory=list)
    false_positive_risk: float = 0.0
    matched_patterns: List[str] = field(default_factory=list)
    additional_context: Dict = field(default_factory=dict)


class ResponseCharacteristics:
    def __init__(self, content: str, status_code: int, headers: Dict, response_time: float):
        self.content = content
        self.status_code = status_code
        self.headers = headers
        self.response_time = response_time
        self.content_length = len(content)
        self.content_hash = hashlib.md5(content.encode()).hexdigest()
        self.is_json = self._is_json_response()
        self.is_html = self._is_html_response()
        self.is_xml = self._is_xml_response()
        self.content_type = headers.get('Content-Type', '').lower()
        self.has_error_indicators = self._has_error_indicators()
    
    def _is_json_response(self) -> bool:
        if 'application/json' in self.content_type:
            return True
        try:
            json.loads(self.content)
            return True
        except:
            return False
    
    def _is_html_response(self) -> bool:
        return 'text/html' in self.content_type or self.content.strip().startswith('<')
    
    def _is_xml_response(self) -> bool:
        return 'xml' in self.content_type or self.content.strip().startswith('<?xml')
    
    def _has_error_indicators(self) -> bool:
        error_status = self.status_code >= 400
        error_keywords = ['error', 'exception', 'fatal', 'warning', 'trace', 'stack']
        has_error_keyword = any(kw in self.content.lower() for kw in error_keywords)
        return error_status or has_error_keyword


class PatternMatcher:
    def __init__(self):
        self.xss_patterns: List[DetectionPattern] = self._build_xss_patterns()
        self.sql_patterns: List[DetectionPattern] = self._build_sql_patterns()
        self.rce_patterns: List[DetectionPattern] = self._build_rce_patterns()
        self.command_patterns: List[DetectionPattern] = self._build_command_patterns()
        self.ssrf_patterns: List[DetectionPattern] = self._build_ssrf_patterns()
        self.xxe_patterns: List[DetectionPattern] = self._build_xxe_patterns()
        self.ssti_patterns: List[DetectionPattern] = self._build_ssti_patterns()
        self.ldap_patterns: List[DetectionPattern] = self._build_ldap_patterns()
        
        self.all_patterns = {
            'XSS': self.xss_patterns,
            'SQL': self.sql_patterns,
            'RCE': self.rce_patterns,
            'CommandInjection': self.command_patterns,
            'SSRF': self.ssrf_patterns,
            'XXE': self.xxe_patterns,
            'SSTI': self.ssti_patterns,
            'LDAP': self.ldap_patterns,
        }
    
    def _build_xss_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r'<script[^>]*>.*?</script>', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'on\w+\s*=\s*["\']?.*?["\']?>', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'<svg[^>]*onload', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'<img[^>]*onerror', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'javascript:', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'<iframe[^>]*src', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'eval\s*\(', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'document\.write', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
            DetectionPattern(r'innerHTML\s*=', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'setTimeout\s*\(.*?function', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
        ]
    
    def _build_sql_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r"SQL\s*syntax|mysql_fetch|syntax\s*error|unclosed\s*quotation", SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r"ORA-\d+|Oracle.*error", SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r"PostgreSQL.*query|psycopg|pgsql", SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r"SQLSTATE|SQLError|Database\s*error", SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r"Column.*not\s*found|Unknown\s*column", SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r"Table.*doesn't?\s*exist|Unknown\s*table", SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r"Access\s*denied|Permission\s*denied", SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
            DetectionPattern(r"Warning.*mysql|Warning.*mysqli", SeverityLevel.HIGH, ConfidenceLevel.MEDIUM),
            DetectionPattern(r"Fatal\s*error.*database", SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r"Query\s*failed|Execution\s*failed", SeverityLevel.HIGH, ConfidenceLevel.MEDIUM),
        ]
    
    def _build_rce_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r'^root:', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'/bin/(bash|sh)', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'uid=\d+.*gid=\d+', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'^total\s+\d+.*\n.*drwx', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'-rw-r--r--\s+\d+\s+\w+\s+\w+', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'Linux.*version', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
            DetectionPattern(r'Windows.*SYSTEM', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'C:\\.*Administrator', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'proc/version|proc/environ', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'\.exe\s+version|kernel\s+version', SeverityLevel.HIGH, ConfidenceLevel.MEDIUM),
        ]
    
    def _build_command_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r'^total\s+\d+', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'^([-d])([-r]){9}', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'\d+\s+(root|bin|daemon|mail)', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'^[a-z]+\s+[a-z]+\s+\d+', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
            DetectionPattern(r'groups=\d+.*uid=\d+', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'real\s+\d+m\d+\.\d+s', SeverityLevel.MEDIUM, ConfidenceLevel.LOW),
        ]
    
    def _build_ssrf_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r'Connection\s*refused|Connection\s*timed\s*out', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
            DetectionPattern(r'No\s*route\s*to\s*host|Host\s*unreachable', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
            DetectionPattern(r'502\s*Bad\s*Gateway|503\s*Service\s*Unavailable', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
            DetectionPattern(r'Internal\s*Server\s*Error.*localhost', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'metadata.*instance|169\.254\.169\.254', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
        ]
    
    def _build_xxe_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r'DOCTYPE.*ENTITY|SYSTEM.*file://', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'root:.*:/bin/.*', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'xml.*parsing.*error|DOCTYPE.*not\s*allowed', SeverityLevel.HIGH, ConfidenceLevel.HIGH),
            DetectionPattern(r'External\s*entity.*disabled|Entity.*not\s*allowed', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
        ]
    
    def _build_ssti_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r'49|7777777', SeverityLevel.CRITICAL, ConfidenceLevel.CERTAIN),
            DetectionPattern(r'\{\{.*7\*7.*\}\}|\$\{.*7\*7.*\}', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'<%.*7\*7.*%>|#set.*7\*7', SeverityLevel.CRITICAL, ConfidenceLevel.HIGH),
            DetectionPattern(r'jinja2|mako|django.*template', SeverityLevel.MEDIUM, ConfidenceLevel.MEDIUM),
        ]
    
    def _build_ldap_patterns(self) -> List[DetectionPattern]:
        return [
            DetectionPattern(r'invalid\s*credentials|LDAP.*error', SeverityLevel.HIGH, ConfidenceLevel.MEDIUM),
            DetectionPattern(r'directory.*error|search.*error', SeverityLevel.MEDIUM, ConfidenceLevel.LOW),
        ]
    
    def match_pattern(self, content: str, pattern: DetectionPattern) -> Optional[str]:
        if not pattern.compiled:
            return None
        
        match = pattern.compiled.search(content)
        return match.group(0) if match else None
    
    def get_patterns_for_type(self, vuln_type: str) -> List[DetectionPattern]:
        return self.all_patterns.get(vuln_type, [])


class FalsePositiveAnalyzer:
    @staticmethod
    def analyze(response: ResponseCharacteristics, matched_patterns: List[str], payload: str) -> float:
        fp_risk = 0.0
        
        if response.status_code < 400 and not payload in response.content:
            fp_risk += 0.2
        
        if 'error' not in response.content.lower() and response.status_code == 200:
            fp_risk += 0.15
        
        if response.response_time > 5.0:
            fp_risk += 0.1
        
        common_strings = ['welcome', 'default', 'apache', 'nginx', 'index.php']
        if any(s in response.content.lower() for s in common_strings):
            fp_risk += 0.1
        
        return min(fp_risk, 1.0)
    
    @staticmethod
    def get_fp_indicators(response_content: str) -> List[str]:
        return [
            'default page',
            'index.php',
            'apache default',
            'nginx default',
            'welcome page',
            'setup page',
        ]


class ContextualAnalyzer:
    @staticmethod
    def analyze_payload_context(payload: str, matched_content: str) -> Dict:
        context = {
            'payload_position': matched_content.find(payload) if payload in matched_content else -1,
            'payload_encoded': FalsePositiveAnalyzer._is_encoded(payload),
            'surrounding_tags': ContextualAnalyzer._extract_surrounding_tags(matched_content, payload),
            'attribute_context': 'href' in matched_content or 'src' in matched_content,
        }
        return context
    
    @staticmethod
    def _is_encoded(payload: str) -> bool:
        encoded_indicators = ['%', '&', '&#', '\\x', '\\u']
        return any(ind in payload for ind in encoded_indicators)
    
    @staticmethod
    def _extract_surrounding_tags(content: str, payload: str) -> List[str]:
        tags = re.findall(r'<(\w+)[^>]*>', content)
        return tags[-3:] if tags else []


class VulnerabilityAggregator:
    def __init__(self):
        self.detections: List[DetectionResult] = []
        self.severity_distribution = defaultdict(int)
    
    def add_detection(self, result: DetectionResult):
        self.detections.append(result)
        self.severity_distribution[result.severity.name] += 1
    
    def get_highest_severity(self) -> Optional[SeverityLevel]:
        if not self.detections:
            return None
        return max((d.severity for d in self.detections if d.is_vulnerable), 
                  default=None, key=lambda x: x.value)
    
    def get_by_severity(self, severity: SeverityLevel) -> List[DetectionResult]:
        return [d for d in self.detections if d.severity == severity and d.is_vulnerable]
    
    def get_summary(self) -> Dict:
        vulnerable_count = sum(1 for d in self.detections if d.is_vulnerable)
        return {
            'total_detections': len(self.detections),
            'vulnerable': vulnerable_count,
            'severity_distribution': dict(self.severity_distribution),
            'average_confidence': sum(d.confidence for d in self.detections) / len(self.detections) if self.detections else 0,
        }


class VulnerabilityDetector:
    def __init__(self):
        self.data_dir = Path(__file__).parent.parent / 'data'
        self.pattern_matcher = PatternMatcher()
        self.fp_analyzer = FalsePositiveAnalyzer()
        self.contextual_analyzer = ContextualAnalyzer()
        self.error_signatures = self._load_error_signatures()
        self.aggregator = VulnerabilityAggregator()
    
    def _load_error_signatures(self) -> Dict:
        filepath = self.data_dir / 'error_signatures.json'
        if filepath.exists():
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                pass
        return self._get_default_signatures()
    
    def _get_default_signatures(self) -> Dict:
        return {
            'SQL': [
                'sql syntax', 'mysql_fetch', 'syntax error', 'unclosed quotation',
                'ORA-01756', 'SQL command not properly ended', 'PostgreSQL query failed',
                'sqlite3.OperationalError', 'MySQL Error', 'SQL Error',
            ],
            'XSS': ['<script>', 'alert(', 'onerror=', 'onload=', 'javascript:'],
            'RCE': ['root:', '/bin/bash', 'uid=', 'gid=', 'groups='],
            'CommandInjection': ['total ', 'drwx', '-rw-', 'root root'],
            'SSRF': ['Connection refused', 'Connection timed out', 'No route to host'],
        }
    
    def detect(self, response: Dict, scan_type: str, payload: str) -> Tuple[bool, Dict]:
        if not response or not response.get('success'):
            return False, {}
        
        characteristics = ResponseCharacteristics(
            response.get('content', ''),
            response.get('status_code', 0),
            response.get('headers', {}),
            response.get('response_time', 0)
        )
        
        detection_method = getattr(self, f'_detect_{scan_type.lower()}', None)
        if detection_method:
            return detection_method(characteristics, payload)
        
        return False, {}
    
    def _detect_xss(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        if payload in characteristics.content:
            result = self._build_detection_result(
                VulnerabilityType.XSS,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.CERTAIN,
                f'Payload reflected in response',
                characteristics,
                payload
            )
            return True, result
        
        patterns = self.pattern_matcher.get_patterns_for_type('XSS')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched:
            max_confidence = max(p.confidence.value for p in patterns if self.pattern_matcher.match_pattern(characteristics.content, p))
            result = self._build_detection_result(
                VulnerabilityType.XSS,
                SeverityLevel.HIGH,
                ConfidenceLevel(max_confidence),
                f'XSS patterns detected: {matched[0][:50]}',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        return False, {}
    
    def _detect_sql(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        patterns = self.pattern_matcher.get_patterns_for_type('SQL')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched:
            severity = SeverityLevel.CRITICAL if characteristics.has_error_indicators else SeverityLevel.HIGH
            result = self._build_detection_result(
                VulnerabilityType.SQL_INJECTION,
                severity,
                ConfidenceLevel.HIGH,
                f'SQL error signature found: {matched[0][:60]}',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        if characteristics.status_code == 500 and characteristics.has_error_indicators:
            result = self._build_detection_result(
                VulnerabilityType.SQL_INJECTION,
                SeverityLevel.HIGH,
                ConfidenceLevel.MEDIUM,
                'Server error with SQL query detected',
                characteristics,
                payload
            )
            return True, result
        
        return False, {}
    
    def _detect_rce(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        patterns = self.pattern_matcher.get_patterns_for_type('RCE')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched:
            result = self._build_detection_result(
                VulnerabilityType.RCE,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.CERTAIN,
                f'Command execution output detected: {matched[0][:40]}',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        if 'total ' in characteristics.content and ('-rw' in characteristics.content or 'drwx' in characteristics.content):
            result = self._build_detection_result(
                VulnerabilityType.RCE,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.HIGH,
                'Directory listing detected - RCE successful',
                characteristics,
                payload
            )
            return True, result
        
        return False, {}
    
    def _detect_commandinjection(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        if 'sleep' in payload.lower() and characteristics.response_time > 4:
            result = self._build_detection_result(
                VulnerabilityType.COMMAND_INJECTION,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.HIGH,
                f'Time-based injection detected: {characteristics.response_time:.2f}s delay',
                characteristics,
                payload
            )
            return True, result
        
        patterns = self.pattern_matcher.get_patterns_for_type('CommandInjection')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched:
            result = self._build_detection_result(
                VulnerabilityType.COMMAND_INJECTION,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.HIGH,
                f'Command output detected: {matched[0][:40]}',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        return False, {}
    
    def _detect_ssrf(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        if characteristics.status_code == 200 and 'localhost' in payload.lower():
            result = self._build_detection_result(
                VulnerabilityType.SSRF,
                SeverityLevel.HIGH,
                ConfidenceLevel.HIGH,
                'SSRF - Internal resource accessed',
                characteristics,
                payload
            )
            return True, result
        
        patterns = self.pattern_matcher.get_patterns_for_type('SSRF')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched:
            result = self._build_detection_result(
                VulnerabilityType.SSRF,
                SeverityLevel.HIGH,
                ConfidenceLevel.MEDIUM,
                f'SSRF indicator found: {matched[0][:40]}',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        return False, {}
    
    def _detect_csrf(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        has_csrf_token = 'csrf' in characteristics.content.lower() or 'token' in characteristics.content.lower()
        has_samesite = any('samesite' in str(v).lower() for v in characteristics.headers.values())
        
        if not has_csrf_token and not has_samesite:
            result = self._build_detection_result(
                VulnerabilityType.CSRF,
                SeverityLevel.MEDIUM,
                ConfidenceLevel.MEDIUM,
                'No CSRF protection detected',
                characteristics,
                payload
            )
            return True, result
        
        return False, {}
    
    def _detect_xxe(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        patterns = self.pattern_matcher.get_patterns_for_type('XXE')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched:
            result = self._build_detection_result(
                VulnerabilityType.XXE,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.CERTAIN,
                f'XXE vulnerability confirmed: {matched[0][:40]}',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        return False, {}
    
    def _detect_ssti(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        patterns = self.pattern_matcher.get_patterns_for_type('SSTI')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched or ('49' in characteristics.content or '7777777' in characteristics.content):
            result = self._build_detection_result(
                VulnerabilityType.SSTI,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.CERTAIN,
                'Server-Side Template Injection confirmed',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        return False, {}
    
    def _detect_ldap(self, characteristics: ResponseCharacteristics, payload: str) -> Tuple[bool, Dict]:
        patterns = self.pattern_matcher.get_patterns_for_type('LDAP')
        matched = []
        
        for pattern in patterns:
            match = self.pattern_matcher.match_pattern(characteristics.content, pattern)
            if match:
                matched.append(match)
        
        if matched:
            result = self._build_detection_result(
                VulnerabilityType.LDAP_INJECTION,
                SeverityLevel.CRITICAL,
                ConfidenceLevel.HIGH,
                'LDAP Injection detected',
                characteristics,
                payload,
                matched
            )
            return True, result
        
        return False, {}
    
    def _build_detection_result(self, vuln_type: VulnerabilityType, severity: SeverityLevel,
                               confidence: ConfidenceLevel, description: str,
                               characteristics: ResponseCharacteristics, payload: str,
                               matched_patterns: Optional[List[str]] = None) -> Dict:
        fp_risk = self.fp_analyzer.analyze(characteristics, matched_patterns or [], payload)
        context = self.contextual_analyzer.analyze_payload_context(payload, characteristics.content)
        
        return {
            'type': vuln_type.name,
            'severity': severity.name,
            'confidence': confidence.value,
            'description': description,
            'evidence': characteristics.content[:200] if characteristics.content else '',
            'false_positive_risk': fp_risk,
            'matched_patterns': matched_patterns or [],
            'context': context,
            'status_code': characteristics.status_code,
            'response_time': characteristics.response_time,
        }
    
    def batch_detect(self, response: Dict, scan_type: str, payloads: List[str]) -> List[Tuple[bool, Dict]]:
        return [self.detect(response, scan_type, payload) for payload in payloads]
    
    def get_detection_summary(self) -> Dict:
        return self.aggregator.get_summary()
    
    def analyze_response_characteristics(self, response: Dict) -> Dict:
        characteristics = ResponseCharacteristics(
            response.get('content', ''),
            response.get('status_code', 0),
            response.get('headers', {}),
            response.get('response_time', 0)
        )
        
        return {
            'is_json': characteristics.is_json,
            'is_html': characteristics.is_html,
            'is_xml': characteristics.is_xml,
            'has_error_indicators': characteristics.has_error_indicators,
            'content_length': characteristics.content_length,
            'content_hash': characteristics.content_hash,
            'content_type': characteristics.content_type,
        }