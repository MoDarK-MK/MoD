from typing import Tuple, Dict, Optional
import re
import json
from pathlib import Path

class VulnerabilityDetector:
    def __init__(self):
        self.data_dir = Path(__file__).parent.parent / 'data'
        self.error_signatures = self._load_error_signatures()
    
    def _load_error_signatures(self) -> Dict:
        filepath = self.data_dir / 'error_signatures.json'
        if filepath.exists():
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        return self._get_default_signatures()
    
    def _get_default_signatures(self) -> Dict:
        return {
            'SQL': [
                'sql syntax',
                'mysql_fetch',
                'syntax error',
                'unclosed quotation',
                'quoted string not properly terminated',
                'ORA-01756',
                'SQL command not properly ended',
                'PostgreSQL query failed',
                'sqlite3.OperationalError'
            ],
            'XSS': [
                '<script>',
                'alert(',
                'onerror=',
                'onload=',
                'javascript:'
            ],
            'RCE': [
                'root:',
                '/bin/bash',
                'uid=',
                'gid=',
                'groups='
            ],
            'CommandInjection': [
                'total ',
                'drwx',
                '-rw-',
                'root root'
            ],
            'SSRF': [
                'Connection refused',
                'Connection timed out',
                'No route to host',
                'Internal Server',
                'localhost'
            ]
        }
    
    def detect(self, response: Dict, scan_type: str, payload: str) -> Tuple[bool, Dict]:
        if scan_type == 'XSS':
            return self._detect_xss(response, payload)
        elif scan_type == 'SQL':
            return self._detect_sql(response, payload)
        elif scan_type == 'RCE':
            return self._detect_rce(response, payload)
        elif scan_type == 'CommandInjection':
            return self._detect_command_injection(response, payload)
        elif scan_type == 'SSRF':
            return self._detect_ssrf(response, payload)
        elif scan_type == 'CSRF':
            return self._detect_csrf(response, payload)
        
        return False, {}
    
    def _detect_xss(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        
        if payload in content:
            return True, {
                'severity': 'High',
                'description': 'Reflected XSS vulnerability detected',
                'evidence': f'Payload reflected in response: {payload[:100]}'
            }
        
        for signature in self.error_signatures.get('XSS', []):
            if signature.lower() in content.lower():
                return True, {
                    'severity': 'Medium',
                    'description': 'Potential XSS vulnerability detected',
                    'evidence': f'XSS signature found: {signature}'
                }
        
        return False, {}
    
    def _detect_sql(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '').lower()
        status_code = response.get('status_code', 0)
        
        for signature in self.error_signatures.get('SQL', []):
            if signature.lower() in content:
                return True, {
                    'severity': 'Critical',
                    'description': 'SQL Injection vulnerability detected',
                    'evidence': f'SQL error signature found: {signature}'
                }
        
        if status_code == 500 and ('error' in content or 'exception' in content):
            return True, {
                'severity': 'High',
                'description': 'Potential SQL Injection causing server error',
                'evidence': 'Server returned 500 error with exception message'
            }
        
        return False, {}
    
    def _detect_rce(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        
        for signature in self.error_signatures.get('RCE', []):
            if signature in content:
                return True, {
                    'severity': 'Critical',
                    'description': 'Remote Code Execution vulnerability detected',
                    'evidence': f'Command output detected: {signature}'
                }
        
        if 'total ' in content and ('-rw' in content or 'drwx' in content):
            return True, {
                'severity': 'Critical',
                'description': 'RCE vulnerability - directory listing detected',
                'evidence': 'Command execution successful (ls output)'
            }
        
        return False, {}
    
    def _detect_command_injection(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        response_time = response.get('response_time', 0)
        
        if 'sleep' in payload.lower() and response_time > 4:
            return True, {
                'severity': 'Critical',
                'description': 'Time-based Command Injection detected',
                'evidence': f'Response delayed by {response_time} seconds'
            }
        
        for signature in self.error_signatures.get('CommandInjection', []):
            if signature in content:
                return True, {
                    'severity': 'Critical',
                    'description': 'Command Injection vulnerability detected',
                    'evidence': f'Command output detected: {signature}'
                }
        
        return False, {}
    
    def _detect_ssrf(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '')
        status_code = response.get('status_code', 0)
        
        if status_code == 200 and 'localhost' in payload.lower():
            return True, {
                'severity': 'High',
                'description': 'SSRF vulnerability - internal resource accessible',
                'evidence': 'Successfully accessed localhost resource'
            }
        
        for signature in self.error_signatures.get('SSRF', []):
            if signature.lower() in content.lower():
                return True, {
                    'severity': 'High',
                    'description': 'Potential SSRF vulnerability detected',
                    'evidence': f'SSRF indicator found: {signature}'
                }
        
        return False, {}
    
    def _detect_csrf(self, response: Dict, payload: str) -> Tuple[bool, Dict]:
        content = response.get('content', '').lower()
        headers = response.get('headers', {})
        
        has_csrf_token = 'csrf' in content or 'token' in content
        has_samesite = any('samesite' in str(v).lower() for v in headers.values())
        
        if not has_csrf_token and not has_samesite:
            return True, {
                'severity': 'Medium',
                'description': 'Potential CSRF vulnerability - no protection detected',
                'evidence': 'No CSRF token or SameSite cookie found'
            }
        
        return False, {}